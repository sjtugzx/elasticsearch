Single Scattering in Refractive Media with Triangle Mesh Boundaries

Bruce Walter

Cornell University

Shuang Zhao

Cornell University

Nicolas Holzschuch

INRIA – LJK

Kavita Bala

Cornell University

teapot

pool

glass tile

glass mosaic

amber

cuboctahedron

bumpy sphere

straight-line approximation

Figure 1: The bending and focusing of light in refractive media creates distinctive rich details. The top row shows single scatter surface caus-
tics in glass and water. The bottom row shows complex volumetric refractive caustics in amber and glass. All images were generated using
the method in this paper, except the bottom right which used the common straight-line approximation that neglects shadow ray refraction.

Abstract
Light scattering in refractive media is an important optical phe-
nomenon for computer graphics. While recent research has focused
on multiple scattering, there has been less work on accurate solu-
tions for single or low-order scattering. Refraction through a com-
plex boundary allows a single external source to be visible in mul-
tiple directions internally with different strengths; these are hard
to ﬁnd with existing techniques. This paper presents techniques to
quickly ﬁnd paths that connect points inside and outside a medium
while obeying the laws of refraction. We introduce: a half-vector
based formulation to support the most common geometric repre-
sentation, triangles with interpolated normals; hierarchical pruning
to scale to triangular meshes; and, both a solver with strong accu-
racy guarantees, and a faster method that is empirically accurate. A
GPU version achieves interactive frame rates in several examples.
CR Categories:
I.3.7 [Computer Graphics]: Three-Dimensional
Graphics and Realism—Color, shading, shadowing, and texture;
Keywords: Refraction, subsurface, single scatter

ACM Reference Format
Walter, B., Zhao, S., Holzschuch, N., Bala, K. 2009. Single Scattering in Refractive Media with Triangle 
Mesh Boundaries. ACM Trans. Graph. 28, 3, Article 92 (August 2009), 8 pages. 
DOI = 10.1145/1531326.1531398 http://doi.acm.org/10.1145/1531326.1531398.

Copyright Notice
Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted 
without fee provided that copies are not made or distributed for proﬁ t or direct commercial advantage 
and that copies show this notice on the ﬁ rst page or initial screen of a display along with the full citation. 
Copyrights for components of this work owned by others than ACM must be honored. Abstracting with 
credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any 
component of this work in other works requires prior speciﬁ c permission and/or a fee. Permissions may be 
requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, 
fax +1 (212) 869-0481, or permissions@acm.org.
© 2009 ACM 0730-0301/2009/03-ART92 $10.00 DOI 10.1145/1531326.1531398 
http://doi.acm.org/10.1145/1531326.1531398

1 Introduction
Single (or low order) scattering is often an important effect in sub-
surface and volumetric materials such as amber or quartz and in
optically thin materials. Unlike multiple scattering which generally
acts as a blurring or low-pass ﬁlter, single scattering can produce
high frequency effects such as volumetric caustics. Single scatter-
ing within a refractive medium is especially challenging because
there may be zero, one, or many paths connecting a scattering loca-
tion (inside the medium) and a light source (outside the medium).
The refraction also can focus or defocus the light depending on the
exact conﬁguration. Figure 1 shows several complex examples.
The most common solution to this problem is to simply ignore it
by directly connecting the light source and scattering point. This
is cheap but inaccurate (see Figure 1, bottom right). Accurate ap-
proaches use random sampling, but this becomes arbitrarily expen-
sive for small light sources or features. There is a lack of efﬁcient,
accurate solutions for computing these important types of paths.
In this paper we explicitly solve for refracted paths that connect a
point inside and a point outside the medium. Our contributions are:
• Formulation of the problem based on the half-vector. This is
necessary to support triangles with smooth shading normals,
the most widely used geometry representation in graphics.
• Robust and efﬁcient iterative techniques to ﬁnd all such paths.
• Hierarchical pruning algorithms to scale to large meshes.
• Derivations and methods for computing the light contribution

along a refracted path.

We will next brieﬂy review previous work in Section 2, then formu-
late the problem and describe our path ﬁnding in Section 3. Sec-

tion 4 describes how to compute the light contribution along each
path. Finally, we present results in Section 5.

2 Previous Work
Our algorithm is related to previous work in several areas.
Subsurface scattering. Hanrahan and Krueger [1993] approxi-
mated single scattering by a BRDF, while using a full Monte-Carlo
solution for multiple scattering. Jensen et al. [2001] simpliﬁed the
multiple scattering case with their dipole approximation, but still
use the BRDF approximation or use shadow rays that ignore re-
fraction for single scattering.
Volume scattering. There has been a lot of work on fast volume
scattering in non-refractive media such as Sun et al. [2005] and
Nishita and Nakamae [1987], but this does not generalize easily
to refractive media.
Accurate reﬂections from curved reﬂectors. Several researchers
have used Fermat’s principle to solve for reﬂection points on curved
reﬂectors. Mitchell and Hanrahan [1992] used differential geom-
etry and interval analysis to compute the exact reﬂection points.
They discuss, but do not demonstrate, ﬁnding refraction points.
Chen and Arvo [2000] compute a quick approximation of reﬂected
rays using a Taylor expansion. Both these approaches are restricted
to implicit surfaces with known equations.
Most models used in computer graphics use triangle meshes. Ofek
and Rappoport [1998] computed the reﬂections of the vertices of
such a triangular mesh. In recent work, similar methods have been
used for interactive rendering, e.g. [Estalella et al. 2006; Roger and
Holzschuch 2006; Szirmay-Kalos et al. 2005; Sz´ecsi 2006]. How-
ever these methods ﬁnd the reﬂection point by ray tracing and then
solve for the approximate reﬂected point. This is a different prob-
lem than the one we are solving.
Beam tracing.
The light refracted through the surface can be
represented by a set of volumetric beams, but the beams have com-
plicated shapes and intensity proﬁles. However fast caustic approx-
imations can be constructed by sampling and interpolating intensity
values in these beams, (e.g., [Nishita and Nakamae 1994; Iwasaki
et al. 2003; Ernst et al. 2005]), though these methods are approxi-
mate and have trouble tracking shadowing of the caustics.
Monte Carlo. Caustics can, in principle, be computed by Monte
Carlo path tracing, but the convergence tends to be very slow when
shadow rays cannot be used, such as in refractive single scatter-
ing, especially if the light source is small. Metropolis Light trans-
port [Veach and Guibas 1997] improves the Monte Carlo conver-
gence rate by exploring perturbations about such paths once found,
but still works best when the light source is large or shadow rays
can be used.
Photon mapping. Photon mapping [Jensen 2001; Jarosz et al.
2008] can estimate the light at any point in space, but the result
is blurred by the size of the kernel needed to reduce the noise. Thus
very large numbers of photons can be necessary to reconstruct sharp
features like caustics, especially with participating media. On the
GPU, photon mapping can be done interactively [Sun et al. 2008]
with impressive results for small scenes, but is still very data inten-
sive and requires high photon counts.
Compared to our method, photon mapping handles a wider variety
of lighting paths, with a cost that depends mostly on the ﬁnest fea-
ture resolution one is trying to reconstruct and the spatial extent of
the scene, due to the view-independent nature of the photon map.
Our method is purely view-dependent but handles only a speciﬁc
class of light paths with cost that depends mainly on the medium
boundary complexity and number of distinct convergent light paths.

Figure 2: (a) Multiple paths (black lines) may connect light L
to scatter point V, while the non-refractive approximation (pur-
ple line) cannot account for these paths. (b) Geometry of problem
at a point P with geometric normal ˆNg and shading normal ˆNs.

3 Finding Refracted Connecting Paths
Our goal is to compute the illumination at a point inside a refrac-
tive medium from a light source outside the medium. Speciﬁ-
cally, we want to ﬁnd all the ways that light from a point L out-
side the medium can reach a scattering point V inside the medium
without scattering in between except for a single refraction event
when it crosses into the refractive medium boundary (see Fig-
ure 2). We assume the index of refraction is piecewise constant with
η = ηin/ηout. We also assume that the refraction obeys Snell’s law
except that it may bend relative to the local shading normal ˆNs
instead of the true geometric normal ˆNg.
To solve this problem, we need to ﬁnd all the points P on the bound-
ary which can refract light from L towards V and compute how
much light travels along each such LPV path.
In this section, we ﬁrst present a half-vector formulation of the
problem that can be used with shading normals. Based on this
formulation we then present fast, iterative solution techniques for:
triangles without shading normals (Section 3.2) and with shading
normals (Section 3.3). For the latter, we provide both a basic it-
erative solution that works well in practice and a more expensive
interval-based modiﬁcation that is guaranteed to ﬁnd all solutions.
And ﬁnally, we present efﬁcient hierarchical algorithms to handle
to media with complex triangle mesh boundaries (Section 3.4).

3.1 Half-vector problem formulation

One way to formulate this problem [Mitchell and Hanrahan 1992]
is using Fermat’s principle. Let us deﬁne the optical path length as
η(cid:107)V−P(cid:107)+(cid:107)L−P(cid:107), then the valid solutions for P are the extremal
points (minima and maxima) of this equation under the restriction
that P must lie on the boundary. Or equivalently, the gradient of
this length (as a function of P) must be collinear with the geometric
surface normal ˆNg(P). However Fermat’s principle does not hold
when using shading normals, such as triangles with interpolated
normals or normal maps. Instead we use an alternate formulation
based on the refractive half-vector ˆH [Walter et al. 2007], which
does generalize easily to handle varying shading normals (i.e., the
geometric normal is not equal to the shading normal, ˆNg (cid:54)= ˆNs).
Let us deﬁne a direction (unit vector) ˆH as follows:

ˆωV =

ˆωL =

ˆH =

V − P
(cid:107)V − P(cid:107)
L − P
(cid:107)L − P(cid:107)
η ˆωV + ˆωL
(cid:107)η ˆωV + ˆωL(cid:107)

(1)

(2)

(3)

Then ˆH is collinear with the surface normal at all valid refraction

3.3 Case 2: Triangle with shading normals
When triangles have varying shading normals, the problem is much
harder. Within the plane of the triangle there may be zero, one, or
multiple solutions for P and they need not lie within a single inci-
dence plane, thus requiring a 2D rather than a simpler 1D search.
We use a two stage strategy; we progressively split the triangle into
smaller sub-triangles until they meet some criteria while trying to
prune out sub-triangles that cannot contain a solution. Then we use
2D Newton-Raphson iteration to locate potential solutions in the re-
maining sub-triangles. We ﬁrst describe the 2D Newton-Raphson.
2D Newton-Raphson. One key to the successful use of Newton-
Raphson and fast convergence is deﬁning a good target function
f. If we express the locations on the sub-triangle using barycentric
coordinates (a, b) so that a point is inside the sub-triangle if a ≥ 0,
b ≥ 0, and a + b ≤ 1, then we can express the point, half-vector,
and shading normals as: P(a, b), ˆH(a, b), and ˆNs(a, b) and deﬁne
the target function as:

f (a, b) = ˆH(a, b) + ˆNs(a, b)

(8)

which from Equation 4 must go to zero when P(a, b) is a valid
refraction solution.
Standard 2D Newton-Raphson uses the inverse of the Jacobian ma-
trix J of f. Since our f maps from 2D to 3D, its Jacobian is
a 3 × 2 matrix and not invertible. We tried several approaches
to this problem but by far the best was to use the pseudo-inverse
J + = (J T J)−1J T . The iteration using the pseudo-inverse is:

–

» ai+1

bi+1

–

» ai

bi

=

− J +(ai, bi) f (ai, bi)

(9)

Computing the Jacobian of f involves repeatedly applying the fol-
lowing rule for the derivative of a normalized vector (derived via
the quotient and chain rules from calculus):

ˆn =

(cid:126)u

(cid:107)(cid:126)u(cid:107) ⇒ ˆn

(cid:48)

=

(cid:107)(cid:126)u(cid:107)2(cid:126)u(cid:48) − ((cid:126)u · (cid:126)u(cid:48))(cid:126)u

(cid:107)(cid:126)u(cid:107)3

(10)

To improve stability, we limit the maximum step size per iteration
((cid:107)(cid:52)a,(cid:52)b(cid:107) ≤ 1/2) and replace a step with a smaller step if it fails
to reduce (cid:107)f(cid:107). We use a0 = 1/3, b0 = 1/3 as our initial starting
guess, but if (cid:107)f (a0, b0)(cid:107) > 1 then we also try a few other starting
points and start with the one with the least (cid:107)f(cid:107) instead. Speciﬁcally
we also try the vertices of the sub-triangle and the projection of V
onto the triangle’s plane along the average shading normal. With
these modiﬁcations, we have found the 2D Newton-Raphson works
very well. It nearly always converges when there is a real solution in
the vicinity of the sub-triangle and usually within 3 to 7 iterations.

3.3.1 Split-and-prune for sub-triangle search
Splitting a triangle into 4 smaller triangles is trivial by splitting each
edge; the interesting part of our recursive split-and-prune approach
for smooth normals is how to detect when a triangle cannot contain
a solution and so can be safely pruned from our search. We accom-
plish this by computing bounding cones for directions − ˆH and ˆNs
and then pruning the triangle whenever these cones do not overlap.
For triangles with interpolated normals, all the shading normals
within the triangle must lie within a spherical triangle deﬁned by
the shading normals at the vertices, and it is easy to compute the
bounding cone of a spherical triangle. We do not yet support nor-
mal mapped triangles, but bounding cones could be precomputed
and stored with the normal map in that case.
Computing a bounding cone on ˆH involves a few more steps. Since
(L−P)/(cid:107)L−P(cid:107) and (V−P)/(cid:107)V−P(cid:107) deﬁne two spherical trian-
gles, we compute 3D axis-aligned bounding boxes for each. Then

Figure 3: The setup for a triangle without shading normals which
reduces the 2D search for P to a 1D search in the incidence plane.

points P, since requiring that the components of ˆH perpendicular
to the normal vanish is equivalent to Snell’s law. Assuming the
relative index of refraction η > 1, P is a valid solution to our
refracted path ﬁnding problem if and only if:

and

ˆH = − ˆNs

(V · ˆNg) ≤ (P · ˆNg) ≤ (L · ˆNg)

(4)
which tests that Snell’s law is obeyed relative to the shading normal
ˆNs and that V and L lie on opposite sides of the local geomet-
ric tangent plane. We use the conventions that the normals point
outwards from the refractive object while ˆH points into the denser
medium.
In general there is no analytical solution for this set of equations.
Prior work has focused on iterative solutions for geometric repre-
sentations with nice analytic properties and derivatives such as im-
plicit surfaces [Mitchell and Hanrahan 1992; Chen and Arvo 2000].
However, the most common geometric representations in computer
graphics are triangle meshes, usually with varying shading normals.
These meshes pose different challenges in terms of solving for the
refracted paths and are the focus of this paper.

3.2 Case 1: Triangle without shading normals
For a triangle without shading normals, if V and L lie on the appro-
priate sides of the triangle’s plane, then there always exists a single
solution P in this plane and it must lie in the incidence plane de-
ﬁned by V, L, and ˆNg. Thus, we can solve for P using a 1D search
and then check to see if it lies within the triangle.
Let us work in a coordinate system such that all the relevant points
lie in the z = 0 plane, the triangle lies in the y = 0 plane and
V is on the y-axis so we can express the problem in 2D using:
V = (0, Vy), P = (x, 0), L = (Lx, Ly), and ˆNg = ˆNs =
(0, 1) (see Figure 3). Then we need only search for x such that
ˆH = − ˆNg. Since we already know ˆH and ˆNg lie in the z = 0
plane, this is equivalent to letting f (x) = ( ˆH · (1, 0)), and we can
use the Newton-Raphson iterative method for ﬁnding x such that
f (x) = 0.

f (x) =

x0 =

p(Lx − x)2 + L2

Lx − x

y

−ηxpx2 + V 2

y

−VyLx
ηLy − Vy

+

4

3 + η

(5)

(6)

(cid:48)

(xi)

xi+1 = xi − f (xi)/f

(7)
where x0 is an initial guess for x, f(cid:48) is the derivative of f with
respect to x, and the last equation is the deﬁnition of 1D Newton-
Raphson iteration. We have intentionally omitted the normalization
term of ˆH since overall scaling factors do not affect the locations
of the zeros of a function. We also clamp all xi to the range [0, Lx]
since the solution must lie in this range. Equation 6 is an empiri-
cal heuristic that required fewer average iterations to converge than
other starting points we tried. With these settings, the Newton-
Raphson always converges, and usually in just 2 to 4 iterations.

we scale the second box by η and take their Minkowski sum (which
just adds the corresponding bounding values) to get a bounding box
on the unnormalized version of ˆH. Lastly we compute a bounding
cone for this box which is also therefore a bounding cone on ˆH.
Note that all of our bounding cones have their apex at the origin.
Finally, two cones overlap if the angle between their axes is less
than the sum of their bounding semiangles.
We have tested two strategies for deciding when to stop subdividing
a triangle and run the Newton iteration. The ﬁrst is a quick heuristic
based on the size of these bounding cones; stop if the sum of the
ˆH and ˆNs cone angles is less than thirty degrees. This heuristic
has worked well in our experience, producing visually good results,
but is not guaranteed to ﬁnd all solutions. The second is a more
expensive interval test with strong guarantees described below.

3.3.2 Guaranteed interval-based reﬁnement test
While 2D Newton iteration converges very quickly (quadratically)
once close enough, it may fail to converge even if a solution exists
and only ﬁnds at most one solution even if there may be several
nearby. This can be ﬁxed by subdividing the triangle until we have
starting points sufﬁciently near every solution, but how do we know
when its safe to stop subdividing? The cone angles heuristic (see
above) works well in practice, but if desired we can get stronger
guarantees using interval tests at the cost of some extra subdivision.
Moore and others [Moore 1977; Rall 1981] introduced interval ex-
tensions to Newton Raphson iteration. The original formulation
required inverting the interval Jacobian matrix, which can be non-
trivial. Krawczyk [1969] introduced a formulation which does not
require inverting an interval matrix. This formulation was also used
by [Mitchell and Hanrahan 1992] for reﬂections. We modify this
formulation to work with our 2D Newton iteration and the pseu-
doinverse. Both Krawczyk and Newton Raphson are iterative ﬁxed
points algorithms where the iteration maps a point to itself if and
only if it is a solution to the equation (i.e., xi+1 = xi ⇔ f (xi) =
0). Krawczyk works with intervals allowing reasoning about re-
gions of the search space, but in the limit of degenerate intervals
(single points), it is identical to Newton Raphson.
Let us introduce some notation. f (a, b) = 0 is the equation we
are solving. X = {Xa, Xb} is a 2D interval representation of
our solution space, where Xa and Xb are intervals on a and b re-
spectively. For any triangle all valid values of a and b lie within
the interval [0, 1]. F(X) is the interval representation of f and in-
cludes all possible values that f can take over points in X. F(cid:48)(X)
is the interval representation of the Jacobian matrix. m(X) is an
operator that replaces each interval in X by its midpoint. Let
m0 = m(X) = (ma, mb) = (0.5, 0.5), and M = m(F(cid:48)(X)).
F(cid:48)(X) is a 3×2 matrix of intervals, M is an ordinary (non-interval)
matrix and M+ is the pseudoinverse of M. We compute K(X) as:

K(X) = m0 − M+f (m0) + [I − M+F
(cid:48)

(X)](X − m0)

(11)

A solution, or ﬁxed point, can not exist in the interval X if either of
these conditions is true:

∅ (cid:54)∈ F(X)
K(X) ∩ X = ∅

(12)
(13)

Furthermore, if both of the following conditions are true, then there
is exactly one unique solution in X, and ordinary (non-interval)
Newton iteration will converge to it.

K(X) ⊆ X
||I − M+F
(X)|| < 1
(cid:48)

(14)
(15)

Figure 4: Spindle test. Valid solutions for P must be within the
shaded region in 2D, and within the surface of revolution in 3D.

where the ﬁrst condition requires that the interval maps back to a
subset of itself, and combined with the second condition guarantees
that the interval continues to shrink at each subsequent iteration.
test, we skip sub-
When using the interval-based reﬁnement
triangles if Equations 12 or 13 are true.
If both Equations 14
and 15 are true, then we switch to ordinary 2D Newton iteration
(guaranteed to converge though the solution may lie outside the
sub-triangle). Otherwise, we recursively subdivide our triangle and
keep searching for solutions.

3.4 Scalability to triangle meshes
For meshes with small numbers of triangles, one can simply test
all triangles for solutions, as described above, but to handle larger
meshes we use a hierarchical pruning process to eliminate whole
groups of triangles that cannot contain a solution. We ﬁrst construct
a hierarchy over the triangles called a position-normal tree [Bala
et al. 2003; Snyder 1992]. This is a binary tree where the leaves
are triangles and each node contains a 3D axis-aligned bounding
box over positions and a bounding cone over shading normals that
is valid for all its descendants. We construct this hierarchy using a
bottom-up approach similar to that in [Walter et al. 2005].
To solve for all refractive connection paths through a triangle mesh,
we perform a depth-ﬁrst traversal of the position-normal tree. At
each node we test to see if we can prune out the subtree by proving it
has no solutions using the following three pruning tests: the spindle
test, the sidedness test, and the cone overlap test. We now brieﬂy
describe each of these tests; for more details see [Walter et al. 2009].
The spindle test. A single refraction can only bend the light by a
limited amount. Even for arbitrarily large values of η, the light can
be bent by at most a right angle and for more reasonable η values,
the bending is more restricted. Speciﬁcally the angle between PL
and PV must form an angle between π/2 + arcsin(1/η) and π
in radians. This is only possible if P lies within a region centered
around the line segment VL as shown in Figure 4. This region,
which we call the spindle, is a surface of revolution of a circular arc
from V to L. This shape is a direct consequence of the refractive
bending angle limit and the inscribed-angle theorem for circles.
We have developed a simple test to see if a bounding box may over-
lap this region. Let r be the distance from a point P to the line
containing L and V. Then the point P lies within the spindle if:

(cid:107)L − V(cid:107)

η

r ≤ (cid:107)L − V(cid:107)2

4

+

(16)

‚‚‚‚P − L + V

2

‚‚‚‚2

If η is arbitrarily large, this reduces to a point in sphere test, but
becomes more stringent as η decreases. We use a slightly modiﬁed
standard box-sphere overlap test to test if the box could overlap the
spindle by also computing a lower bound on the distance from the
box to the line containing V and L. This test is cheap to compute
and does not depend on the shading normals, allowing it to prune
many subtrees even if they have large normal bounding cones.
The sidedness test. For a point to be a valid refraction point, L
must lie on the positive side of its shading normal, and V must

lie on the negative side of the shading normal and within a cone
bounded by the critical angle, arcsin(1/η). Using techniques
from [Walter et al. 2005], we compute bounds on the angles be-
tween the axis of the shading normal bounding cone and L and V
as seen from any point in the position bounding box. We then offset
these by the semiangle of the normal bounding cone and see if it is
possible for the respective angles to lie within the required ranges.
The cone overlap test. This test is a simple extension of the prun-
ing test used for pruning sub-triangles in the smooth normal case.
The one difference is that the positions are bounded by a 3D box
rather than a 2D triangle, but the test is otherwise the same.

4 Contribution of Refracted Light Paths
Once we have computed a refracted path connecting L and V
through some point P on the boundary, we need to compute how
much contribution it makes to the illumination. Most of the terms
are similar to the contribution from a regular shadow ray. For ex-
ample, if L is a point light with intensity Ie, F is the fresnel factor
at P, A is the volume attenuation (i.e., integral of σs along the line
segment inside the media), and V is a volume scattering event with
phase function ρ, then the contribution for an unoccluded path is:

contribution =

Ie F A ρ

D

(17)

where D is the distance correction factor discussed below. If the
medium is clear then A = 1. If V is a surface point, then replace ρ
with the BRDF times the cosine of angle with surface normal at V.
If simulating an area light then replace Ie with the emitted radiance
times the cosine of angle with surface normal at L, divided by the
probability of sampling L.
If there is no refraction (η = 1) then we have the usual distance
squared factor, D = (cid:107)L − V(cid:107)2. If there is refraction but we are at
normal incidence without shading normals, ˆωL = ˆNg = ˆNs, then
we get D = ((cid:107)P − V(cid:107) + η(cid:107)L − P(cid:107))2. For the special case of no
shading normals (i.e., ˆNs = ˆNg) the exact equation is:

D = (dV + ηdL)

|ˆωV · ˆNg| dV +

|ˆωV · ˆNg|
|ˆωL · ˆNg| ηdL

(18)

  |ˆωL · ˆNg|

!

with dV and dL deﬁned below.
In the general case of shading normals, D is more complex and does
not seem to have a simple equation. Computing D correctly is nec-
essary to get visually good results that match reference solutions.
First, we compute derivatives for L in the plane perpendicular to ˆωL
with respect to perturbations in ˆωV , which is equivalent to comput-
ing the solid angle of a small area around L as seen from V. This
was inspired by and uses techniques from ray differentials [Igehy
1999]. We compute this differential using the following equations:

!

ˆωV

dV = (cid:107)V − P(cid:107)
dL = (cid:107)L − P(cid:107)
(cid:48)
(cid:48)

 

P

ˆω

= dV

V − ˆω(cid:48)

V · ˆNg
ˆωV · ˆNg
µ = ˆωL · ˆNs + η ˆωV · ˆNs
(cid:48)

!“

 

µ

=

η2 ˆωV · ˆNs
ˆωL · ˆNs
(cid:48)
V + µ
(cid:48) − (P

+ η

V · ˆNs + ˆωV · ˆN
(cid:48)
(cid:48)
s

ˆω

(cid:48)
L = η ˆω
ˆω
(cid:48)
= P
L

(cid:48)
(cid:48) ˆNs + µ ˆN
s
(cid:48) · ˆωL)ˆωL + dL ˆω

(24)
(25)
where we use the notation that a(cid:48) is the derivative of a with respect
to a small perturbation in ˆωV and perpendicular to it. We compute

(cid:48)
L

(19)
(20)

(21)

(22)

(23)

”

model
teapot
cuboctahedron
amber
glass tile
glass mosaic
pool
bumpy sphere

boundary

12
20
36
798
20813
2632
9680

smooth

N
N
N
Y
Y
Y
Y

other
4096

0

60556

60
1450
4324

0

time
15.3s
13.9s
19.2s
66.9s
87.8s
59.4s
304.3s

Figure 5: Results for CPU version of our method on seven models.
Shows the number of triangles in refractive boundaries, whenever
the boundary uses interpolated normals, the number of other trian-
gles in the scene, and time to compute a 512x512 image using 64
samples per pixel (except bumpy sphere used 128 samples).

these derivatives for two different directions perpendicular to ˆωV
and to each other to get L(cid:48)
⊥ and L(cid:48)
(cid:107) and the correct distance factor
from their vector cross product as:
D = (cid:107)L
⊥ × L
(cid:107)(cid:107)
(cid:48)
(cid:48)

(26)

We were surprised by the seeming complexity of D, but have not
managed to ﬁnd a simpler form for it. However, it is not difﬁcult to
code once the equations are known and the only other piece needed
is the ability to compute the derivatives of the shading normal ˆNs
which can easily be computed for triangles with interpolated nor-
mals [Igehy 1999]. For more discussion see [Walter et al. 2009].

5 Results
We implemented our refractive path ﬁnding algorithms in both CPU
and GPU versions. The CPU version is implemented in a Java-
based ray tracer using Sun’s 1.6 server JVM and running on an 8-
core, 2.83 Ghz machine (dual Intel Xeon 5440 chips). All CPU re-
sults are for 512× 512 images with 64 samples per pixel except the
bumpy sphere that used 128. Each eye ray is traced through refrac-
tive or reﬂective bounces until it hits a diffuse or glossy surface or
scatters in a volume (importance sampled according to the volume
attenuation along eye ray). For points inside a refractive medium,
we connect it to the light source using our techniques by ﬁnding all
connecting refractive paths, checking them for occlusion, and com-
puting their contribution. Points outside the medium are shaded us-
ing conventional direct illumination. Results and statistics for our
scenes are shown in Figures 1 and 5. All the refractive media are
homogeneous with η = 1.5. Each scene is lit by one point light
except for the pool which has two small area lights.
The only additional storage required beyond a normal ray tracer is
the position-normal tree, currently about 100 bytes per boundary
triangle in our implementation. The tree build is very fast; for the
glass tile model it takes 6ms and the tree only needs to be rebuilt if
the geometry deforms non-rigidly.
The ﬁrst three models demonstrate faceted refraction without in-
terpolated normals. The teapot embedded in purple glass exam-
ple shows interesting refractive effects even in a very simple con-
ﬁguration with three distinct refractive beams lighting the teapot.
The cuboctahedron shows single scatter volume caustics including
brightening due to beam overlap near edges and vertices. The scor-
pion in amber combines both volume and surface effects.
The glass tile is a piece of rounded glass with a diffuse backing,
modeled with only 798 triangles but with interpolated normals to
simulate a smooth surface. You can see sharp caustics caused by
the focusing of light by the simulated curved surface. The glass
mosaic combines 25 such glass tiles into a more complex shape.
The pool is modeled after a famous image from [Veach and Guibas
1997], but with two much smaller area lights that make the caustics
sharper and much harder to ﬁnd by conventional methods.

photon map

our result

straight-line

path tracing

Figure 6: Glossy teapot embedded in purple glass cube model ren-
dered using photon mapping with 20 000 photons and our result.
The photon map solution shows blurring, light leaks, and other vi-
sual artifacts despite taking twice as long to compute as our result.
Bottom row shows a zoom-in of a region in the result images.

The bumpy sphere is our most challenging model because it focuses
light into surprisingly small, detailed volume caustics in its interior.
The radiance can grow arbitrarily large near focal points or cusps
in such caustics leading to spike noise when sampling the volume
along eye rays, even if the region has little effect on the integral due
to its small size. This noise can be greatly reduced by clamping D
(Equation 26) to be larger than a minimum threshold at the cost of
some energy loss. For this model only, we used a manually chosen
clamping threshold that reduced noise with little energy loss, but
more research is needed in automatic ways to handle such caustics.

We used our cone-angles subdivision heuristic for all result images.
The interval-based reﬁnement test with convergence guarantees is
typically 2 to 5 times slower depending on the scene, while produc-
ing visually equivalent images for these examples. On rare occa-
sions, the heuristic misses a few paths near caustic cusps that the
interval test ﬁnds, but in our results this affects at most a few pixels
and the differences are hard to spot. The position-normal tree and
hierarchical pruning are essential for good performance on bound-
ary meshes with more than a few triangles. For example the pool
scene took 59.4s to render with the reﬁnement heuristic and hierar-
chy, 141.1s with the interval reﬁnement test, and 1934.6s without
hierarchical pruning (slowing down by 2.4x and 32x respectively).

A comparison with photon mapping for the teapot model is shown
in Figure 6. Photon mapping is a versatile algorithm that can sim-
ulate a wider range of light paths than our technique. However the
blurring inherent in its density estimation kernel can cause a variety
of visual artifacts. In this example, even though the photon map im-
age took twice as long as our result, you can see signiﬁcant blurring
of the shadow boundaries, light leaks that coupled with the glossy
BRDF lead to bright speckles, and faceting artifacts caused by dis-
continuities in the photon distribution between facets coupled with
the shading normal modiﬁed BRDF. Typically a ﬁnal gather pass is
used to greatly ameliorate such artifacts, but for single scattering,
this is not feasible as it would degenerate to path tracing.

The bumpy sphere rendered with four different algorithms is shown
in Figure 7. The common approximation of ignoring refraction on
shadow rays is cheap, but eliminates all the visually rich detail in
the image. To get path tracing to work at all on this scene we had
to replace the point light with a small area light and then conver-
gence is very slow. Even after 1.4 hours, the path tracing result is

photon map

our result

Figure 7: Back lit bumpy sphere with four rendering algorithms.
The straight-line approximation cannot capture the volume caus-
tics. Path tracing required replacing the point light with a small
area source and even with 32 768 samples per pixel (compute time:
1.4 hours) produces a very noisy result (white region is a reﬂec-
tion of the area source). The photon map is much better and takes
roughly equal time as our result, but even with ten million photons,
it still blurs out the ﬁner details of the caustics as shown in the bot-
tom row zoom-in. Our algorithm is able to capture these ﬁne details
without the high memory or time requirements of the other methods.

extremely noisy. Bidirectional path tracing would be even less ef-
ﬁcient for the types of paths we are simulating. Photon mapping is
much better, but requires very high photon densities to reduce its in-
herent blurring. In this example, even storing a ten million photons
in the sphere is not enough to resolve the ﬁne detail that you can
see in our result. Photon mapping and our result took roughly equal
time, but our method uses far less memory (hundreds of kilobytes
vs. hundreds of megabytes) and captures ﬁner details.
GPU results. We have also implemented a slightly more limited
GPU version of our algorithm that allows us to achieve interac-
tive performance on several models. The GPU version is written
in CUDA 2.0 and runs on an nVIDIA GTX 280 card with driver
version 181.20. We used a GPU ray tracer based on [Popov et al.
2007] along with the methods described in this paper except that
we do not perform dynamic triangle subdivision on the GPU. Each
GPU thread handles all the tasks for a pixel including ray tracing,
hierarchical pruning, and Newton iteration. Results used 2 samples
per pixel for anti-aliasing, but with multiple volume samples per
eye ray (40 for cuboctahedron and 100 for amber). Timing statis-
tics for our GPU version are in Figure 8. Result images from the
GPU are shown in the accompanying video. A complete version
for Intel’s forthcoming Larrabee platform is also being developed.
Limitations. Our method is designed to ﬁnd refractive connections

model
teapot
cuboctahedron
amber
glass tile

time
0.1s
0.14s
0.3s
6.9s

fps
10fps
7fps
3fps

0.14fps

Figure 8: Results for GPU version of our method on four scenes.

that only cross the refractive boundary once. Thus while it works
well for many caustic effects inside a medium, there are other caus-
tic effects it cannot compute such as the caustic a glass object casts
on a table. Our method is easily extended to simulate low-order
scattering by continuing the eye rays, but is not a good way to com-
pute higher-order scattering such as in the diffusion regime where
other more appropriate approximations exist. Our method assumes
the index of refraction is constant inside the medium (e.g., most
glass or water but not a hot air mirage) though other volume prop-
erties such as the scattering coefﬁcients could be inhomogeneous.

6 Conclusions
We have presented an accurate and efﬁcient solution for solving for
single scattering in a refractive medium. This is an important class
of light paths which are often neglected or approximated simplisti-
cally, due to the difﬁculty of solving these paths accurately and due
to the relative lack of general solution methods.
Our techniques explicitly solve for paths connecting two points:
one inside a refractive medium and the other outside. We present a
formulation of this problem that can handle triangle meshes with in-
terpolated, or otherwise perturbed, shading normals. We introduce
techniques to solve for paths through individual triangles and hier-
archical culling techniques to handle larger meshes without needing
to test every triangle. We have also presented an exact method to
compute the contribution along each such refracted path. Our paper
allows us to compute single scattering in refractive media efﬁciently
without sacriﬁcing accuracy.
We believe our work can be extended to enhance Monte Carlo algo-
rithms such as bidirectional path tracing by allowing them to con-
nect subpaths in different media thus allowing them to more efﬁ-
ciently ﬁnd these types of problematic paths. Our work could also
be used to compute reﬂective caustics with a small change in def-
inition of the half-vector and pruning tests. It is also possible to
extend the method to ﬁnd paths that cross more than one refractive
boundary. However this would greatly expand the search space and
better culling methods would be needed to make this practical.

Acknowledgements This work was supported by NSF CAREER 0644175,
NSF CPA 0811680, NSF CNS 0615240, NSF CNS 0403340, and grants
from Intel Corporation, NVidia Corporation, and Microsoft Corporation.
This work was started while N. Holzschuch was on a sabbatical at Cornell,
funded by INRIA, and he’d like to acknowledge the INRIA CIPRUS asso-
ciate team. LJK is UMR 5224, a joint research laboratory of CNRS, INRIA,
INPG, U. Grenoble I and U. Grenoble II.

References

ESTALELLA, P., MARTIN, I., DRETTAKIS, G., AND TOST, D.
2006. A gpu-driven algorithm for accurate interactive reﬂections
In Rendering Techniques 2006 (Proc. EG
on curved objects.
Symp. on Rendering).

HANRAHAN, P., AND KRUEGER, W. 1993. Reﬂection from lay-
ered surfaces due to subsurface scattering. In Computer Graph-
ics Proceedings, ACM SIGGRAPH, Annual Conference Series,
165–174.

IGEHY, H. 1999. Tracing ray differentials. In Computer Graph-
ics Proceedings, ACM SIGGRAPH, Annual Conference Series,
179–186.

IWASAKI, K., DOBASHI, Y., AND NISHITA, T. 2003. A fast ren-
dering method for refractive and reﬂective caustics due to water
surfaces. Computer Graphics Forum 22, 3 (Sept.), 601–610.

JAROSZ, W., ZWICKER, M., AND JENSEN, H. W. 2008. The
beam radiance estimate for volumetric photon mapping. Com-
puter Graphics Forum (Proc. Eurographics ’08) 27, 2.

JENSEN, H. W., MARSCHNER, S. R., LEVOY, M., AND HANRA-
HAN, P. 2001. A practical model for subsurface light transport.
In Computer Graphics Proc., ACM SIGGRAPH, Annual Conf.
Series, 511–518.

JENSEN, H. W. 2001. Realistic Image Synthesis Using Photon

Mapping. AK Peters.

KRAWCZYK, R. 1969. Newton-algorithmen zur bestimmung von

nullstellen mit fehlerschranken. Computing 4, 3, 187–201.

MITCHELL, D., AND HANRAHAN, P. 1992.

Illumination from
curved reﬂectors. Computer Graphics (Proc. of Siggraph) 26, 3,
283–291.

MOORE, R. E. 1977. A test for existence of solutions for non-linear
systems. SIAM Journal on Numerical Analysis 14, 4, 611–615.

NISHITA, T., AND NAKAMAE, E. 1994. Method of displaying
optical effects within water using accumulation buffer. In Com-
puter Graphics Proceedings, ACM SIGGRAPH, Annual Con-
ference Series, 373–379.

NISHITA, T., MIYAWAKI, Y., AND NAKAMAE, E. 1987. A shad-
ing model for atmospheric scattering considering luminous in-
tensity distribution of light sources. Computer Graphics (Proc.
of Siggraph) 21, 4, 303–310.

OFEK, E., AND RAPPOPORT, A. 1998.

on curved objects.
SIGGRAPH, Annual Conference Series, 333 – 342.

Interactive reﬂections
In Computer Graphics Proceedings, ACM

POPOV, S., G ¨UNTHER, J., SEIDEL, H.-P., AND SLUSALLEK, P.
2007. Stackless kd-tree traversal for high performance gpu ray
tracing. Computer Graphics Forum 26, 3 (Sept.), 415–424.

RALL, L. B. 1981. Automatic Differentiation: Techniques and
Applications, vol. 120 of Lecture Notes in Computer Science.
Springer.

BALA, K., WALTER, B., AND GREENBERG, D. P. 2003. Combin-
ing edges and points for interactive high-quality rendering. ACM
Transactions on Graphics 22, 3, 631–640.

ROGER, D., AND HOLZSCHUCH, N. 2006. Accurate specular
reﬂections in real-time. Computer Graphics Forum (Proc. of EG
2006) 25, 3.

CHEN, M., AND ARVO, J. 2000. Theory and application of spec-
ular path perturbation. ACM Transactions on Graphics 19, 4,
246–278.

ERNST, M., AKENINE-M ¨OLLER, T., AND JENSEN, H. W. 2005.
Interactive rendering of caustics using interpolated warped vol-
umes. In Graphics Interface 2005, 87–96.

SNYDER, J. M. 1992.

Interval analysis for computer graphics.

Computer Graphics 26, 4 (July), 121–130.

SUN, B., RAMAMOORTHI, R., NARASIMHAN, S. G., AND NA-
YAR, S. K. 2005. A practical analytic single scattering model
for real time rendering. ACM Transactions on Graphics 24, 3,
1040–1049.

SUN, X., ZHOU, K., STOLLNITZ, E., SHI, J., AND GUO, B. 2008.
Interactive relighting of dynamic refractive objects. ACM Trans-
actions on Graphics 27, 3 (Aug.), 35:1–35:9.

SZ ´ECSI, L. 2006. The hierarchical ray engine. In WSCG (Winter

School of Computer Graphics).

SZIRMAY-KALOS, L., ASZ ´ODI, B., LAZ ´ANYI, I., AND PRE-
MECZ, M. 2005. Approximate ray-tracing on the GPU with dis-
tance impostors. Computer Graphics Forum (Proc. Eurograph-
ics ’05) 24, 3.

VEACH, E., AND GUIBAS, L. J. 1997. Metropolis light transport.
In Computer Graphics Proceedings, ACM SIGGRAPH, Annual
Conference Series, 65–76.

WALTER, B., FERNANDEZ, S., ARBREE, A., BALA, K.,
DONIKIAN, M., AND GREENBERG, D. P. 2005. Lightcuts: A
scalable approach to illumination. ACM Transactions on Graph-
ics 24, 3 (Aug.), 1098–1107.

WALTER, B., MARSCHNER, S. R., LI, H., AND TORRANCE,
K. E. 2007. Microfacet Models for Refraction through Rough
In Rendering Techniques (Proc. EG Symposium on
Surfaces .
Rendering), 195–206.

WALTER, B., ZHAO, S., HOLZSCHUCH, N., AND BALA, K. 2009.
Supplemental to single scattering in refractive media with tri-
angle mesh boundaries. Technical Report PCG-09-01, Cornell
Program of Computer Graphics, June.

Single Scattering in Refractive Media with Triangle Mesh Boundaries

Bruce Walter

Cornell University

Shuang Zhao

Cornell University

Nicolas Holzschuch

INRIA – LJK

Kavita Bala

Cornell University

teapot

pool

glass tile

glass mosaic

amber

cuboctahedron

bumpy sphere

straight-line approximation

Figure 1: The bending and focusing of light in refractive media creates distinctive rich details. The top row shows single scatter surface caus-
tics in glass and water. The bottom row shows complex volumetric refractive caustics in amber and glass. All images were generated using
the method in this paper, except the bottom right which used the common straight-line approximation that neglects shadow ray refraction.

Abstract
Light scattering in refractive media is an important optical phe-
nomenon for computer graphics. While recent research has focused
on multiple scattering, there has been less work on accurate solu-
tions for single or low-order scattering. Refraction through a com-
plex boundary allows a single external source to be visible in mul-
tiple directions internally with different strengths; these are hard
to ﬁnd with existing techniques. This paper presents techniques to
quickly ﬁnd paths that connect points inside and outside a medium
while obeying the laws of refraction. We introduce: a half-vector
based formulation to support the most common geometric repre-
sentation, triangles with interpolated normals; hierarchical pruning
to scale to triangular meshes; and, both a solver with strong accu-
racy guarantees, and a faster method that is empirically accurate. A
GPU version achieves interactive frame rates in several examples.
CR Categories:
I.3.7 [Computer Graphics]: Three-Dimensional
Graphics and Realism—Color, shading, shadowing, and texture;
Keywords: Refraction, subsurface, single scatter

ACM Reference Format
Walter, B., Zhao, S., Holzschuch, N., Bala, K. 2009. Single Scattering in Refractive Media with Triangle 
Mesh Boundaries. ACM Trans. Graph. 28, 3, Article 92 (August 2009), 8 pages. 
DOI = 10.1145/1531326.1531398 http://doi.acm.org/10.1145/1531326.1531398.

Copyright Notice
Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted 
without fee provided that copies are not made or distributed for proﬁ t or direct commercial advantage 
and that copies show this notice on the ﬁ rst page or initial screen of a display along with the full citation. 
Copyrights for components of this work owned by others than ACM must be honored. Abstracting with 
credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any 
component of this work in other works requires prior speciﬁ c permission and/or a fee. Permissions may be 
requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, 
fax +1 (212) 869-0481, or permissions@acm.org.
© 2009 ACM 0730-0301/2009/03-ART92 $10.00 DOI 10.1145/1531326.1531398 
http://doi.acm.org/10.1145/1531326.1531398

1 Introduction
Single (or low order) scattering is often an important effect in sub-
surface and volumetric materials such as amber or quartz and in
optically thin materials. Unlike multiple scattering which generally
acts as a blurring or low-pass ﬁlter, single scattering can produce
high frequency effects such as volumetric caustics. Single scatter-
ing within a refractive medium is especially challenging because
there may be zero, one, or many paths connecting a scattering loca-
tion (inside the medium) and a light source (outside the medium).
The refraction also can focus or defocus the light depending on the
exact conﬁguration. Figure 1 shows several complex examples.
The most common solution to this problem is to simply ignore it
by directly connecting the light source and scattering point. This
is cheap but inaccurate (see Figure 1, bottom right). Accurate ap-
proaches use random sampling, but this becomes arbitrarily expen-
sive for small light sources or features. There is a lack of efﬁcient,
accurate solutions for computing these important types of paths.
In this paper we explicitly solve for refracted paths that connect a
point inside and a point outside the medium. Our contributions are:
• Formulation of the problem based on the half-vector. This is
necessary to support triangles with smooth shading normals,
the most widely used geometry representation in graphics.
• Robust and efﬁcient iterative techniques to ﬁnd all such paths.
• Hierarchical pruning algorithms to scale to large meshes.
• Derivations and methods for computing the light contribution

along a refracted path.

We will next brieﬂy review previous work in Section 2, then formu-
late the problem and describe our path ﬁnding in Section 3. Sec-

tion 4 describes how to compute the light contribution along each
path. Finally, we present results in Section 5.

2 Previous Work
Our algorithm is related to previous work in several areas.
Subsurface scattering. Hanrahan and Krueger [1993] approxi-
mated single scattering by a BRDF, while using a full Monte-Carlo
solution for multiple scattering. Jensen et al. [2001] simpliﬁed the
multiple scattering case with their dipole approximation, but still
use the BRDF approximation or use shadow rays that ignore re-
fraction for single scattering.
Volume scattering. There has been a lot of work on fast volume
scattering in non-refractive media such as Sun et al. [2005] and
Nishita and Nakamae [1987], but this does not generalize easily
to refractive media.
Accurate reﬂections from curved reﬂectors. Several researchers
have used Fermat’s principle to solve for reﬂection points on curved
reﬂectors. Mitchell and Hanrahan [1992] used differential geom-
etry and interval analysis to compute the exact reﬂection points.
They discuss, but do not demonstrate, ﬁnding refraction points.
Chen and Arvo [2000] compute a quick approximation of reﬂected
rays using a Taylor expansion. Both these approaches are restricted
to implicit surfaces with known equations.
Most models used in computer graphics use triangle meshes. Ofek
and Rappoport [1998] computed the reﬂections of the vertices of
such a triangular mesh. In recent work, similar methods have been
used for interactive rendering, e.g. [Estalella et al. 2006; Roger and
Holzschuch 2006; Szirmay-Kalos et al. 2005; Sz´ecsi 2006]. How-
ever these methods ﬁnd the reﬂection point by ray tracing and then
solve for the approximate reﬂected point. This is a different prob-
lem than the one we are solving.
Beam tracing.
The light refracted through the surface can be
represented by a set of volumetric beams, but the beams have com-
plicated shapes and intensity proﬁles. However fast caustic approx-
imations can be constructed by sampling and interpolating intensity
values in these beams, (e.g., [Nishita and Nakamae 1994; Iwasaki
et al. 2003; Ernst et al. 2005]), though these methods are approxi-
mate and have trouble tracking shadowing of the caustics.
Monte Carlo. Caustics can, in principle, be computed by Monte
Carlo path tracing, but the convergence tends to be very slow when
shadow rays cannot be used, such as in refractive single scatter-
ing, especially if the light source is small. Metropolis Light trans-
port [Veach and Guibas 1997] improves the Monte Carlo conver-
gence rate by exploring perturbations about such paths once found,
but still works best when the light source is large or shadow rays
can be used.
Photon mapping. Photon mapping [Jensen 2001; Jarosz et al.
2008] can estimate the light at any point in space, but the result
is blurred by the size of the kernel needed to reduce the noise. Thus
very large numbers of photons can be necessary to reconstruct sharp
features like caustics, especially with participating media. On the
GPU, photon mapping can be done interactively [Sun et al. 2008]
with impressive results for small scenes, but is still very data inten-
sive and requires high photon counts.
Compared to our method, photon mapping handles a wider variety
of lighting paths, with a cost that depends mostly on the ﬁnest fea-
ture resolution one is trying to reconstruct and the spatial extent of
the scene, due to the view-independent nature of the photon map.
Our method is purely view-dependent but handles only a speciﬁc
class of light paths with cost that depends mainly on the medium
boundary complexity and number of distinct convergent light paths.

Figure 2: (a) Multiple paths (black lines) may connect light L
to scatter point V, while the non-refractive approximation (pur-
ple line) cannot account for these paths. (b) Geometry of problem
at a point P with geometric normal ˆNg and shading normal ˆNs.

3 Finding Refracted Connecting Paths
Our goal is to compute the illumination at a point inside a refrac-
tive medium from a light source outside the medium. Speciﬁ-
cally, we want to ﬁnd all the ways that light from a point L out-
side the medium can reach a scattering point V inside the medium
without scattering in between except for a single refraction event
when it crosses into the refractive medium boundary (see Fig-
ure 2). We assume the index of refraction is piecewise constant with
η = ηin/ηout. We also assume that the refraction obeys Snell’s law
except that it may bend relative to the local shading normal ˆNs
instead of the true geometric normal ˆNg.
To solve this problem, we need to ﬁnd all the points P on the bound-
ary which can refract light from L towards V and compute how
much light travels along each such LPV path.
In this section, we ﬁrst present a half-vector formulation of the
problem that can be used with shading normals. Based on this
formulation we then present fast, iterative solution techniques for:
triangles without shading normals (Section 3.2) and with shading
normals (Section 3.3). For the latter, we provide both a basic it-
erative solution that works well in practice and a more expensive
interval-based modiﬁcation that is guaranteed to ﬁnd all solutions.
And ﬁnally, we present efﬁcient hierarchical algorithms to handle
to media with complex triangle mesh boundaries (Section 3.4).

3.1 Half-vector problem formulation

One way to formulate this problem [Mitchell and Hanrahan 1992]
is using Fermat’s principle. Let us deﬁne the optical path length as
η(cid:107)V−P(cid:107)+(cid:107)L−P(cid:107), then the valid solutions for P are the extremal
points (minima and maxima) of this equation under the restriction
that P must lie on the boundary. Or equivalently, the gradient of
this length (as a function of P) must be collinear with the geometric
surface normal ˆNg(P). However Fermat’s principle does not hold
when using shading normals, such as triangles with interpolated
normals or normal maps. Instead we use an alternate formulation
based on the refractive half-vector ˆH [Walter et al. 2007], which
does generalize easily to handle varying shading normals (i.e., the
geometric normal is not equal to the shading normal, ˆNg (cid:54)= ˆNs).
Let us deﬁne a direction (unit vector) ˆH as follows:

ˆωV =

ˆωL =

ˆH =

V − P
(cid:107)V − P(cid:107)
L − P
(cid:107)L − P(cid:107)
η ˆωV + ˆωL
(cid:107)η ˆωV + ˆωL(cid:107)

(1)

(2)

(3)

Then ˆH is collinear with the surface normal at all valid refraction

3.3 Case 2: Triangle with shading normals
When triangles have varying shading normals, the problem is much
harder. Within the plane of the triangle there may be zero, one, or
multiple solutions for P and they need not lie within a single inci-
dence plane, thus requiring a 2D rather than a simpler 1D search.
We use a two stage strategy; we progressively split the triangle into
smaller sub-triangles until they meet some criteria while trying to
prune out sub-triangles that cannot contain a solution. Then we use
2D Newton-Raphson iteration to locate potential solutions in the re-
maining sub-triangles. We ﬁrst describe the 2D Newton-Raphson.
2D Newton-Raphson. One key to the successful use of Newton-
Raphson and fast convergence is deﬁning a good target function
f. If we express the locations on the sub-triangle using barycentric
coordinates (a, b) so that a point is inside the sub-triangle if a ≥ 0,
b ≥ 0, and a + b ≤ 1, then we can express the point, half-vector,
and shading normals as: P(a, b), ˆH(a, b), and ˆNs(a, b) and deﬁne
the target function as:

f (a, b) = ˆH(a, b) + ˆNs(a, b)

(8)

which from Equation 4 must go to zero when P(a, b) is a valid
refraction solution.
Standard 2D Newton-Raphson uses the inverse of the Jacobian ma-
trix J of f. Since our f maps from 2D to 3D, its Jacobian is
a 3 × 2 matrix and not invertible. We tried several approaches
to this problem but by far the best was to use the pseudo-inverse
J + = (J T J)−1J T . The iteration using the pseudo-inverse is:

–

» ai+1

bi+1

–

» ai

bi

=

− J +(ai, bi) f (ai, bi)

(9)

Computing the Jacobian of f involves repeatedly applying the fol-
lowing rule for the derivative of a normalized vector (derived via
the quotient and chain rules from calculus):

ˆn =

(cid:126)u

(cid:107)(cid:126)u(cid:107) ⇒ ˆn

(cid:48)

=

(cid:107)(cid:126)u(cid:107)2(cid:126)u(cid:48) − ((cid:126)u · (cid:126)u(cid:48))(cid:126)u

(cid:107)(cid:126)u(cid:107)3

(10)

To improve stability, we limit the maximum step size per iteration
((cid:107)(cid:52)a,(cid:52)b(cid:107) ≤ 1/2) and replace a step with a smaller step if it fails
to reduce (cid:107)f(cid:107). We use a0 = 1/3, b0 = 1/3 as our initial starting
guess, but if (cid:107)f (a0, b0)(cid:107) > 1 then we also try a few other starting
points and start with the one with the least (cid:107)f(cid:107) instead. Speciﬁcally
we also try the vertices of the sub-triangle and the projection of V
onto the triangle’s plane along the average shading normal. With
these modiﬁcations, we have found the 2D Newton-Raphson works
very well. It nearly always converges when there is a real solution in
the vicinity of the sub-triangle and usually within 3 to 7 iterations.

3.3.1 Split-and-prune for sub-triangle search
Splitting a triangle into 4 smaller triangles is trivial by splitting each
edge; the interesting part of our recursive split-and-prune approach
for smooth normals is how to detect when a triangle cannot contain
a solution and so can be safely pruned from our search. We accom-
plish this by computing bounding cones for directions − ˆH and ˆNs
and then pruning the triangle whenever these cones do not overlap.
For triangles with interpolated normals, all the shading normals
within the triangle must lie within a spherical triangle deﬁned by
the shading normals at the vertices, and it is easy to compute the
bounding cone of a spherical triangle. We do not yet support nor-
mal mapped triangles, but bounding cones could be precomputed
and stored with the normal map in that case.
Computing a bounding cone on ˆH involves a few more steps. Since
(L−P)/(cid:107)L−P(cid:107) and (V−P)/(cid:107)V−P(cid:107) deﬁne two spherical trian-
gles, we compute 3D axis-aligned bounding boxes for each. Then

Figure 3: The setup for a triangle without shading normals which
reduces the 2D search for P to a 1D search in the incidence plane.

points P, since requiring that the components of ˆH perpendicular
to the normal vanish is equivalent to Snell’s law. Assuming the
relative index of refraction η > 1, P is a valid solution to our
refracted path ﬁnding problem if and only if:

and

ˆH = − ˆNs

(V · ˆNg) ≤ (P · ˆNg) ≤ (L · ˆNg)

(4)
which tests that Snell’s law is obeyed relative to the shading normal
ˆNs and that V and L lie on opposite sides of the local geomet-
ric tangent plane. We use the conventions that the normals point
outwards from the refractive object while ˆH points into the denser
medium.
In general there is no analytical solution for this set of equations.
Prior work has focused on iterative solutions for geometric repre-
sentations with nice analytic properties and derivatives such as im-
plicit surfaces [Mitchell and Hanrahan 1992; Chen and Arvo 2000].
However, the most common geometric representations in computer
graphics are triangle meshes, usually with varying shading normals.
These meshes pose different challenges in terms of solving for the
refracted paths and are the focus of this paper.

3.2 Case 1: Triangle without shading normals
For a triangle without shading normals, if V and L lie on the appro-
priate sides of the triangle’s plane, then there always exists a single
solution P in this plane and it must lie in the incidence plane de-
ﬁned by V, L, and ˆNg. Thus, we can solve for P using a 1D search
and then check to see if it lies within the triangle.
Let us work in a coordinate system such that all the relevant points
lie in the z = 0 plane, the triangle lies in the y = 0 plane and
V is on the y-axis so we can express the problem in 2D using:
V = (0, Vy), P = (x, 0), L = (Lx, Ly), and ˆNg = ˆNs =
(0, 1) (see Figure 3). Then we need only search for x such that
ˆH = − ˆNg. Since we already know ˆH and ˆNg lie in the z = 0
plane, this is equivalent to letting f (x) = ( ˆH · (1, 0)), and we can
use the Newton-Raphson iterative method for ﬁnding x such that
f (x) = 0.

f (x) =

x0 =

p(Lx − x)2 + L2

Lx − x

y

−ηxpx2 + V 2

y

−VyLx
ηLy − Vy

+

4

3 + η

(5)

(6)

(cid:48)

(xi)

xi+1 = xi − f (xi)/f

(7)
where x0 is an initial guess for x, f(cid:48) is the derivative of f with
respect to x, and the last equation is the deﬁnition of 1D Newton-
Raphson iteration. We have intentionally omitted the normalization
term of ˆH since overall scaling factors do not affect the locations
of the zeros of a function. We also clamp all xi to the range [0, Lx]
since the solution must lie in this range. Equation 6 is an empiri-
cal heuristic that required fewer average iterations to converge than
other starting points we tried. With these settings, the Newton-
Raphson always converges, and usually in just 2 to 4 iterations.

we scale the second box by η and take their Minkowski sum (which
just adds the corresponding bounding values) to get a bounding box
on the unnormalized version of ˆH. Lastly we compute a bounding
cone for this box which is also therefore a bounding cone on ˆH.
Note that all of our bounding cones have their apex at the origin.
Finally, two cones overlap if the angle between their axes is less
than the sum of their bounding semiangles.
We have tested two strategies for deciding when to stop subdividing
a triangle and run the Newton iteration. The ﬁrst is a quick heuristic
based on the size of these bounding cones; stop if the sum of the
ˆH and ˆNs cone angles is less than thirty degrees. This heuristic
has worked well in our experience, producing visually good results,
but is not guaranteed to ﬁnd all solutions. The second is a more
expensive interval test with strong guarantees described below.

3.3.2 Guaranteed interval-based reﬁnement test
While 2D Newton iteration converges very quickly (quadratically)
once close enough, it may fail to converge even if a solution exists
and only ﬁnds at most one solution even if there may be several
nearby. This can be ﬁxed by subdividing the triangle until we have
starting points sufﬁciently near every solution, but how do we know
when its safe to stop subdividing? The cone angles heuristic (see
above) works well in practice, but if desired we can get stronger
guarantees using interval tests at the cost of some extra subdivision.
Moore and others [Moore 1977; Rall 1981] introduced interval ex-
tensions to Newton Raphson iteration. The original formulation
required inverting the interval Jacobian matrix, which can be non-
trivial. Krawczyk [1969] introduced a formulation which does not
require inverting an interval matrix. This formulation was also used
by [Mitchell and Hanrahan 1992] for reﬂections. We modify this
formulation to work with our 2D Newton iteration and the pseu-
doinverse. Both Krawczyk and Newton Raphson are iterative ﬁxed
points algorithms where the iteration maps a point to itself if and
only if it is a solution to the equation (i.e., xi+1 = xi ⇔ f (xi) =
0). Krawczyk works with intervals allowing reasoning about re-
gions of the search space, but in the limit of degenerate intervals
(single points), it is identical to Newton Raphson.
Let us introduce some notation. f (a, b) = 0 is the equation we
are solving. X = {Xa, Xb} is a 2D interval representation of
our solution space, where Xa and Xb are intervals on a and b re-
spectively. For any triangle all valid values of a and b lie within
the interval [0, 1]. F(X) is the interval representation of f and in-
cludes all possible values that f can take over points in X. F(cid:48)(X)
is the interval representation of the Jacobian matrix. m(X) is an
operator that replaces each interval in X by its midpoint. Let
m0 = m(X) = (ma, mb) = (0.5, 0.5), and M = m(F(cid:48)(X)).
F(cid:48)(X) is a 3×2 matrix of intervals, M is an ordinary (non-interval)
matrix and M+ is the pseudoinverse of M. We compute K(X) as:

K(X) = m0 − M+f (m0) + [I − M+F
(cid:48)

(X)](X − m0)

(11)

A solution, or ﬁxed point, can not exist in the interval X if either of
these conditions is true:

∅ (cid:54)∈ F(X)
K(X) ∩ X = ∅

(12)
(13)

Furthermore, if both of the following conditions are true, then there
is exactly one unique solution in X, and ordinary (non-interval)
Newton iteration will converge to it.

K(X) ⊆ X
||I − M+F
(X)|| < 1
(cid:48)

(14)
(15)

Figure 4: Spindle test. Valid solutions for P must be within the
shaded region in 2D, and within the surface of revolution in 3D.

where the ﬁrst condition requires that the interval maps back to a
subset of itself, and combined with the second condition guarantees
that the interval continues to shrink at each subsequent iteration.
test, we skip sub-
When using the interval-based reﬁnement
triangles if Equations 12 or 13 are true.
If both Equations 14
and 15 are true, then we switch to ordinary 2D Newton iteration
(guaranteed to converge though the solution may lie outside the
sub-triangle). Otherwise, we recursively subdivide our triangle and
keep searching for solutions.

3.4 Scalability to triangle meshes
For meshes with small numbers of triangles, one can simply test
all triangles for solutions, as described above, but to handle larger
meshes we use a hierarchical pruning process to eliminate whole
groups of triangles that cannot contain a solution. We ﬁrst construct
a hierarchy over the triangles called a position-normal tree [Bala
et al. 2003; Snyder 1992]. This is a binary tree where the leaves
are triangles and each node contains a 3D axis-aligned bounding
box over positions and a bounding cone over shading normals that
is valid for all its descendants. We construct this hierarchy using a
bottom-up approach similar to that in [Walter et al. 2005].
To solve for all refractive connection paths through a triangle mesh,
we perform a depth-ﬁrst traversal of the position-normal tree. At
each node we test to see if we can prune out the subtree by proving it
has no solutions using the following three pruning tests: the spindle
test, the sidedness test, and the cone overlap test. We now brieﬂy
describe each of these tests; for more details see [Walter et al. 2009].
The spindle test. A single refraction can only bend the light by a
limited amount. Even for arbitrarily large values of η, the light can
be bent by at most a right angle and for more reasonable η values,
the bending is more restricted. Speciﬁcally the angle between PL
and PV must form an angle between π/2 + arcsin(1/η) and π
in radians. This is only possible if P lies within a region centered
around the line segment VL as shown in Figure 4. This region,
which we call the spindle, is a surface of revolution of a circular arc
from V to L. This shape is a direct consequence of the refractive
bending angle limit and the inscribed-angle theorem for circles.
We have developed a simple test to see if a bounding box may over-
lap this region. Let r be the distance from a point P to the line
containing L and V. Then the point P lies within the spindle if:

(cid:107)L − V(cid:107)

η

r ≤ (cid:107)L − V(cid:107)2

4

+

(16)

‚‚‚‚P − L + V

2

‚‚‚‚2

If η is arbitrarily large, this reduces to a point in sphere test, but
becomes more stringent as η decreases. We use a slightly modiﬁed
standard box-sphere overlap test to test if the box could overlap the
spindle by also computing a lower bound on the distance from the
box to the line containing V and L. This test is cheap to compute
and does not depend on the shading normals, allowing it to prune
many subtrees even if they have large normal bounding cones.
The sidedness test. For a point to be a valid refraction point, L
must lie on the positive side of its shading normal, and V must

lie on the negative side of the shading normal and within a cone
bounded by the critical angle, arcsin(1/η). Using techniques
from [Walter et al. 2005], we compute bounds on the angles be-
tween the axis of the shading normal bounding cone and L and V
as seen from any point in the position bounding box. We then offset
these by the semiangle of the normal bounding cone and see if it is
possible for the respective angles to lie within the required ranges.
The cone overlap test. This test is a simple extension of the prun-
ing test used for pruning sub-triangles in the smooth normal case.
The one difference is that the positions are bounded by a 3D box
rather than a 2D triangle, but the test is otherwise the same.

4 Contribution of Refracted Light Paths
Once we have computed a refracted path connecting L and V
through some point P on the boundary, we need to compute how
much contribution it makes to the illumination. Most of the terms
are similar to the contribution from a regular shadow ray. For ex-
ample, if L is a point light with intensity Ie, F is the fresnel factor
at P, A is the volume attenuation (i.e., integral of σs along the line
segment inside the media), and V is a volume scattering event with
phase function ρ, then the contribution for an unoccluded path is:

contribution =

Ie F A ρ

D

(17)

where D is the distance correction factor discussed below. If the
medium is clear then A = 1. If V is a surface point, then replace ρ
with the BRDF times the cosine of angle with surface normal at V.
If simulating an area light then replace Ie with the emitted radiance
times the cosine of angle with surface normal at L, divided by the
probability of sampling L.
If there is no refraction (η = 1) then we have the usual distance
squared factor, D = (cid:107)L − V(cid:107)2. If there is refraction but we are at
normal incidence without shading normals, ˆωL = ˆNg = ˆNs, then
we get D = ((cid:107)P − V(cid:107) + η(cid:107)L − P(cid:107))2. For the special case of no
shading normals (i.e., ˆNs = ˆNg) the exact equation is:

D = (dV + ηdL)

|ˆωV · ˆNg| dV +

|ˆωV · ˆNg|
|ˆωL · ˆNg| ηdL

(18)

  |ˆωL · ˆNg|

!

with dV and dL deﬁned below.
In the general case of shading normals, D is more complex and does
not seem to have a simple equation. Computing D correctly is nec-
essary to get visually good results that match reference solutions.
First, we compute derivatives for L in the plane perpendicular to ˆωL
with respect to perturbations in ˆωV , which is equivalent to comput-
ing the solid angle of a small area around L as seen from V. This
was inspired by and uses techniques from ray differentials [Igehy
1999]. We compute this differential using the following equations:

!

ˆωV

dV = (cid:107)V − P(cid:107)
dL = (cid:107)L − P(cid:107)
(cid:48)
(cid:48)

 

P

ˆω

= dV

V − ˆω(cid:48)

V · ˆNg
ˆωV · ˆNg
µ = ˆωL · ˆNs + η ˆωV · ˆNs
(cid:48)

!“

 

µ

=

η2 ˆωV · ˆNs
ˆωL · ˆNs
(cid:48)
V + µ
(cid:48) − (P

+ η

V · ˆNs + ˆωV · ˆN
(cid:48)
(cid:48)
s

ˆω

(cid:48)
L = η ˆω
ˆω
(cid:48)
= P
L

(cid:48)
(cid:48) ˆNs + µ ˆN
s
(cid:48) · ˆωL)ˆωL + dL ˆω

(24)
(25)
where we use the notation that a(cid:48) is the derivative of a with respect
to a small perturbation in ˆωV and perpendicular to it. We compute

(cid:48)
L

(19)
(20)

(21)

(22)

(23)

”

model
teapot
cuboctahedron
amber
glass tile
glass mosaic
pool
bumpy sphere

boundary

12
20
36
798
20813
2632
9680

smooth

N
N
N
Y
Y
Y
Y

other
4096

0

60556

60
1450
4324

0

time
15.3s
13.9s
19.2s
66.9s
87.8s
59.4s
304.3s

Figure 5: Results for CPU version of our method on seven models.
Shows the number of triangles in refractive boundaries, whenever
the boundary uses interpolated normals, the number of other trian-
gles in the scene, and time to compute a 512x512 image using 64
samples per pixel (except bumpy sphere used 128 samples).

these derivatives for two different directions perpendicular to ˆωV
and to each other to get L(cid:48)
⊥ and L(cid:48)
(cid:107) and the correct distance factor
from their vector cross product as:
D = (cid:107)L
⊥ × L
(cid:107)(cid:107)
(cid:48)
(cid:48)

(26)

We were surprised by the seeming complexity of D, but have not
managed to ﬁnd a simpler form for it. However, it is not difﬁcult to
code once the equations are known and the only other piece needed
is the ability to compute the derivatives of the shading normal ˆNs
which can easily be computed for triangles with interpolated nor-
mals [Igehy 1999]. For more discussion see [Walter et al. 2009].

5 Results
We implemented our refractive path ﬁnding algorithms in both CPU
and GPU versions. The CPU version is implemented in a Java-
based ray tracer using Sun’s 1.6 server JVM and running on an 8-
core, 2.83 Ghz machine (dual Intel Xeon 5440 chips). All CPU re-
sults are for 512× 512 images with 64 samples per pixel except the
bumpy sphere that used 128. Each eye ray is traced through refrac-
tive or reﬂective bounces until it hits a diffuse or glossy surface or
scatters in a volume (importance sampled according to the volume
attenuation along eye ray). For points inside a refractive medium,
we connect it to the light source using our techniques by ﬁnding all
connecting refractive paths, checking them for occlusion, and com-
puting their contribution. Points outside the medium are shaded us-
ing conventional direct illumination. Results and statistics for our
scenes are shown in Figures 1 and 5. All the refractive media are
homogeneous with η = 1.5. Each scene is lit by one point light
except for the pool which has two small area lights.
The only additional storage required beyond a normal ray tracer is
the position-normal tree, currently about 100 bytes per boundary
triangle in our implementation. The tree build is very fast; for the
glass tile model it takes 6ms and the tree only needs to be rebuilt if
the geometry deforms non-rigidly.
The ﬁrst three models demonstrate faceted refraction without in-
terpolated normals. The teapot embedded in purple glass exam-
ple shows interesting refractive effects even in a very simple con-
ﬁguration with three distinct refractive beams lighting the teapot.
The cuboctahedron shows single scatter volume caustics including
brightening due to beam overlap near edges and vertices. The scor-
pion in amber combines both volume and surface effects.
The glass tile is a piece of rounded glass with a diffuse backing,
modeled with only 798 triangles but with interpolated normals to
simulate a smooth surface. You can see sharp caustics caused by
the focusing of light by the simulated curved surface. The glass
mosaic combines 25 such glass tiles into a more complex shape.
The pool is modeled after a famous image from [Veach and Guibas
1997], but with two much smaller area lights that make the caustics
sharper and much harder to ﬁnd by conventional methods.

photon map

our result

straight-line

path tracing

Figure 6: Glossy teapot embedded in purple glass cube model ren-
dered using photon mapping with 20 000 photons and our result.
The photon map solution shows blurring, light leaks, and other vi-
sual artifacts despite taking twice as long to compute as our result.
Bottom row shows a zoom-in of a region in the result images.

The bumpy sphere is our most challenging model because it focuses
light into surprisingly small, detailed volume caustics in its interior.
The radiance can grow arbitrarily large near focal points or cusps
in such caustics leading to spike noise when sampling the volume
along eye rays, even if the region has little effect on the integral due
to its small size. This noise can be greatly reduced by clamping D
(Equation 26) to be larger than a minimum threshold at the cost of
some energy loss. For this model only, we used a manually chosen
clamping threshold that reduced noise with little energy loss, but
more research is needed in automatic ways to handle such caustics.

We used our cone-angles subdivision heuristic for all result images.
The interval-based reﬁnement test with convergence guarantees is
typically 2 to 5 times slower depending on the scene, while produc-
ing visually equivalent images for these examples. On rare occa-
sions, the heuristic misses a few paths near caustic cusps that the
interval test ﬁnds, but in our results this affects at most a few pixels
and the differences are hard to spot. The position-normal tree and
hierarchical pruning are essential for good performance on bound-
ary meshes with more than a few triangles. For example the pool
scene took 59.4s to render with the reﬁnement heuristic and hierar-
chy, 141.1s with the interval reﬁnement test, and 1934.6s without
hierarchical pruning (slowing down by 2.4x and 32x respectively).

A comparison with photon mapping for the teapot model is shown
in Figure 6. Photon mapping is a versatile algorithm that can sim-
ulate a wider range of light paths than our technique. However the
blurring inherent in its density estimation kernel can cause a variety
of visual artifacts. In this example, even though the photon map im-
age took twice as long as our result, you can see signiﬁcant blurring
of the shadow boundaries, light leaks that coupled with the glossy
BRDF lead to bright speckles, and faceting artifacts caused by dis-
continuities in the photon distribution between facets coupled with
the shading normal modiﬁed BRDF. Typically a ﬁnal gather pass is
used to greatly ameliorate such artifacts, but for single scattering,
this is not feasible as it would degenerate to path tracing.

The bumpy sphere rendered with four different algorithms is shown
in Figure 7. The common approximation of ignoring refraction on
shadow rays is cheap, but eliminates all the visually rich detail in
the image. To get path tracing to work at all on this scene we had
to replace the point light with a small area light and then conver-
gence is very slow. Even after 1.4 hours, the path tracing result is

photon map

our result

Figure 7: Back lit bumpy sphere with four rendering algorithms.
The straight-line approximation cannot capture the volume caus-
tics. Path tracing required replacing the point light with a small
area source and even with 32 768 samples per pixel (compute time:
1.4 hours) produces a very noisy result (white region is a reﬂec-
tion of the area source). The photon map is much better and takes
roughly equal time as our result, but even with ten million photons,
it still blurs out the ﬁner details of the caustics as shown in the bot-
tom row zoom-in. Our algorithm is able to capture these ﬁne details
without the high memory or time requirements of the other methods.

extremely noisy. Bidirectional path tracing would be even less ef-
ﬁcient for the types of paths we are simulating. Photon mapping is
much better, but requires very high photon densities to reduce its in-
herent blurring. In this example, even storing a ten million photons
in the sphere is not enough to resolve the ﬁne detail that you can
see in our result. Photon mapping and our result took roughly equal
time, but our method uses far less memory (hundreds of kilobytes
vs. hundreds of megabytes) and captures ﬁner details.
GPU results. We have also implemented a slightly more limited
GPU version of our algorithm that allows us to achieve interac-
tive performance on several models. The GPU version is written
in CUDA 2.0 and runs on an nVIDIA GTX 280 card with driver
version 181.20. We used a GPU ray tracer based on [Popov et al.
2007] along with the methods described in this paper except that
we do not perform dynamic triangle subdivision on the GPU. Each
GPU thread handles all the tasks for a pixel including ray tracing,
hierarchical pruning, and Newton iteration. Results used 2 samples
per pixel for anti-aliasing, but with multiple volume samples per
eye ray (40 for cuboctahedron and 100 for amber). Timing statis-
tics for our GPU version are in Figure 8. Result images from the
GPU are shown in the accompanying video. A complete version
for Intel’s forthcoming Larrabee platform is also being developed.
Limitations. Our method is designed to ﬁnd refractive connections

model
teapot
cuboctahedron
amber
glass tile

time
0.1s
0.14s
0.3s
6.9s

fps
10fps
7fps
3fps

0.14fps

Figure 8: Results for GPU version of our method on four scenes.

that only cross the refractive boundary once. Thus while it works
well for many caustic effects inside a medium, there are other caus-
tic effects it cannot compute such as the caustic a glass object casts
on a table. Our method is easily extended to simulate low-order
scattering by continuing the eye rays, but is not a good way to com-
pute higher-order scattering such as in the diffusion regime where
other more appropriate approximations exist. Our method assumes
the index of refraction is constant inside the medium (e.g., most
glass or water but not a hot air mirage) though other volume prop-
erties such as the scattering coefﬁcients could be inhomogeneous.

6 Conclusions
We have presented an accurate and efﬁcient solution for solving for
single scattering in a refractive medium. This is an important class
of light paths which are often neglected or approximated simplisti-
cally, due to the difﬁculty of solving these paths accurately and due
to the relative lack of general solution methods.
Our techniques explicitly solve for paths connecting two points:
one inside a refractive medium and the other outside. We present a
formulation of this problem that can handle triangle meshes with in-
terpolated, or otherwise perturbed, shading normals. We introduce
techniques to solve for paths through individual triangles and hier-
archical culling techniques to handle larger meshes without needing
to test every triangle. We have also presented an exact method to
compute the contribution along each such refracted path. Our paper
allows us to compute single scattering in refractive media efﬁciently
without sacriﬁcing accuracy.
We believe our work can be extended to enhance Monte Carlo algo-
rithms such as bidirectional path tracing by allowing them to con-
nect subpaths in different media thus allowing them to more efﬁ-
ciently ﬁnd these types of problematic paths. Our work could also
be used to compute reﬂective caustics with a small change in def-
inition of the half-vector and pruning tests. It is also possible to
extend the method to ﬁnd paths that cross more than one refractive
boundary. However this would greatly expand the search space and
better culling methods would be needed to make this practical.

Acknowledgements This work was supported by NSF CAREER 0644175,
NSF CPA 0811680, NSF CNS 0615240, NSF CNS 0403340, and grants
from Intel Corporation, NVidia Corporation, and Microsoft Corporation.
This work was started while N. Holzschuch was on a sabbatical at Cornell,
funded by INRIA, and he’d like to acknowledge the INRIA CIPRUS asso-
ciate team. LJK is UMR 5224, a joint research laboratory of CNRS, INRIA,
INPG, U. Grenoble I and U. Grenoble II.

References

ESTALELLA, P., MARTIN, I., DRETTAKIS, G., AND TOST, D.
2006. A gpu-driven algorithm for accurate interactive reﬂections
In Rendering Techniques 2006 (Proc. EG
on curved objects.
Symp. on Rendering).

HANRAHAN, P., AND KRUEGER, W. 1993. Reﬂection from lay-
ered surfaces due to subsurface scattering. In Computer Graph-
ics Proceedings, ACM SIGGRAPH, Annual Conference Series,
165–174.

IGEHY, H. 1999. Tracing ray differentials. In Computer Graph-
ics Proceedings, ACM SIGGRAPH, Annual Conference Series,
179–186.

IWASAKI, K., DOBASHI, Y., AND NISHITA, T. 2003. A fast ren-
dering method for refractive and reﬂective caustics due to water
surfaces. Computer Graphics Forum 22, 3 (Sept.), 601–610.

JAROSZ, W., ZWICKER, M., AND JENSEN, H. W. 2008. The
beam radiance estimate for volumetric photon mapping. Com-
puter Graphics Forum (Proc. Eurographics ’08) 27, 2.

JENSEN, H. W., MARSCHNER, S. R., LEVOY, M., AND HANRA-
HAN, P. 2001. A practical model for subsurface light transport.
In Computer Graphics Proc., ACM SIGGRAPH, Annual Conf.
Series, 511–518.

JENSEN, H. W. 2001. Realistic Image Synthesis Using Photon

Mapping. AK Peters.

KRAWCZYK, R. 1969. Newton-algorithmen zur bestimmung von

nullstellen mit fehlerschranken. Computing 4, 3, 187–201.

MITCHELL, D., AND HANRAHAN, P. 1992.

Illumination from
curved reﬂectors. Computer Graphics (Proc. of Siggraph) 26, 3,
283–291.

MOORE, R. E. 1977. A test for existence of solutions for non-linear
systems. SIAM Journal on Numerical Analysis 14, 4, 611–615.

NISHITA, T., AND NAKAMAE, E. 1994. Method of displaying
optical effects within water using accumulation buffer. In Com-
puter Graphics Proceedings, ACM SIGGRAPH, Annual Con-
ference Series, 373–379.

NISHITA, T., MIYAWAKI, Y., AND NAKAMAE, E. 1987. A shad-
ing model for atmospheric scattering considering luminous in-
tensity distribution of light sources. Computer Graphics (Proc.
of Siggraph) 21, 4, 303–310.

OFEK, E., AND RAPPOPORT, A. 1998.

on curved objects.
SIGGRAPH, Annual Conference Series, 333 – 342.

Interactive reﬂections
In Computer Graphics Proceedings, ACM

POPOV, S., G ¨UNTHER, J., SEIDEL, H.-P., AND SLUSALLEK, P.
2007. Stackless kd-tree traversal for high performance gpu ray
tracing. Computer Graphics Forum 26, 3 (Sept.), 415–424.

RALL, L. B. 1981. Automatic Differentiation: Techniques and
Applications, vol. 120 of Lecture Notes in Computer Science.
Springer.

BALA, K., WALTER, B., AND GREENBERG, D. P. 2003. Combin-
ing edges and points for interactive high-quality rendering. ACM
Transactions on Graphics 22, 3, 631–640.

ROGER, D., AND HOLZSCHUCH, N. 2006. Accurate specular
reﬂections in real-time. Computer Graphics Forum (Proc. of EG
2006) 25, 3.

CHEN, M., AND ARVO, J. 2000. Theory and application of spec-
ular path perturbation. ACM Transactions on Graphics 19, 4,
246–278.

ERNST, M., AKENINE-M ¨OLLER, T., AND JENSEN, H. W. 2005.
Interactive rendering of caustics using interpolated warped vol-
umes. In Graphics Interface 2005, 87–96.

SNYDER, J. M. 1992.

Interval analysis for computer graphics.

Computer Graphics 26, 4 (July), 121–130.

SUN, B., RAMAMOORTHI, R., NARASIMHAN, S. G., AND NA-
YAR, S. K. 2005. A practical analytic single scattering model
for real time rendering. ACM Transactions on Graphics 24, 3,
1040–1049.

SUN, X., ZHOU, K., STOLLNITZ, E., SHI, J., AND GUO, B. 2008.
Interactive relighting of dynamic refractive objects. ACM Trans-
actions on Graphics 27, 3 (Aug.), 35:1–35:9.

SZ ´ECSI, L. 2006. The hierarchical ray engine. In WSCG (Winter

School of Computer Graphics).

SZIRMAY-KALOS, L., ASZ ´ODI, B., LAZ ´ANYI, I., AND PRE-
MECZ, M. 2005. Approximate ray-tracing on the GPU with dis-
tance impostors. Computer Graphics Forum (Proc. Eurograph-
ics ’05) 24, 3.

VEACH, E., AND GUIBAS, L. J. 1997. Metropolis light transport.
In Computer Graphics Proceedings, ACM SIGGRAPH, Annual
Conference Series, 65–76.

WALTER, B., FERNANDEZ, S., ARBREE, A., BALA, K.,
DONIKIAN, M., AND GREENBERG, D. P. 2005. Lightcuts: A
scalable approach to illumination. ACM Transactions on Graph-
ics 24, 3 (Aug.), 1098–1107.

WALTER, B., MARSCHNER, S. R., LI, H., AND TORRANCE,
K. E. 2007. Microfacet Models for Refraction through Rough
In Rendering Techniques (Proc. EG Symposium on
Surfaces .
Rendering), 195–206.

WALTER, B., ZHAO, S., HOLZSCHUCH, N., AND BALA, K. 2009.
Supplemental to single scattering in refractive media with tri-
angle mesh boundaries. Technical Report PCG-09-01, Cornell
Program of Computer Graphics, June.

Single Scattering in Refractive Media with Triangle Mesh Boundaries

Bruce Walter

Cornell University

Shuang Zhao

Cornell University

Nicolas Holzschuch

INRIA – LJK

Kavita Bala

Cornell University

teapot

pool

glass tile

glass mosaic

amber

cuboctahedron

bumpy sphere

straight-line approximation

Figure 1: The bending and focusing of light in refractive media creates distinctive rich details. The top row shows single scatter surface caus-
tics in glass and water. The bottom row shows complex volumetric refractive caustics in amber and glass. All images were generated using
the method in this paper, except the bottom right which used the common straight-line approximation that neglects shadow ray refraction.

Abstract
Light scattering in refractive media is an important optical phe-
nomenon for computer graphics. While recent research has focused
on multiple scattering, there has been less work on accurate solu-
tions for single or low-order scattering. Refraction through a com-
plex boundary allows a single external source to be visible in mul-
tiple directions internally with different strengths; these are hard
to ﬁnd with existing techniques. This paper presents techniques to
quickly ﬁnd paths that connect points inside and outside a medium
while obeying the laws of refraction. We introduce: a half-vector
based formulation to support the most common geometric repre-
sentation, triangles with interpolated normals; hierarchical pruning
to scale to triangular meshes; and, both a solver with strong accu-
racy guarantees, and a faster method that is empirically accurate. A
GPU version achieves interactive frame rates in several examples.
CR Categories:
I.3.7 [Computer Graphics]: Three-Dimensional
Graphics and Realism—Color, shading, shadowing, and texture;
Keywords: Refraction, subsurface, single scatter

ACM Reference Format
Walter, B., Zhao, S., Holzschuch, N., Bala, K. 2009. Single Scattering in Refractive Media with Triangle 
Mesh Boundaries. ACM Trans. Graph. 28, 3, Article 92 (August 2009), 8 pages. 
DOI = 10.1145/1531326.1531398 http://doi.acm.org/10.1145/1531326.1531398.

Copyright Notice
Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted 
without fee provided that copies are not made or distributed for proﬁ t or direct commercial advantage 
and that copies show this notice on the ﬁ rst page or initial screen of a display along with the full citation. 
Copyrights for components of this work owned by others than ACM must be honored. Abstracting with 
credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any 
component of this work in other works requires prior speciﬁ c permission and/or a fee. Permissions may be 
requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, 
fax +1 (212) 869-0481, or permissions@acm.org.
© 2009 ACM 0730-0301/2009/03-ART92 $10.00 DOI 10.1145/1531326.1531398 
http://doi.acm.org/10.1145/1531326.1531398

1 Introduction
Single (or low order) scattering is often an important effect in sub-
surface and volumetric materials such as amber or quartz and in
optically thin materials. Unlike multiple scattering which generally
acts as a blurring or low-pass ﬁlter, single scattering can produce
high frequency effects such as volumetric caustics. Single scatter-
ing within a refractive medium is especially challenging because
there may be zero, one, or many paths connecting a scattering loca-
tion (inside the medium) and a light source (outside the medium).
The refraction also can focus or defocus the light depending on the
exact conﬁguration. Figure 1 shows several complex examples.
The most common solution to this problem is to simply ignore it
by directly connecting the light source and scattering point. This
is cheap but inaccurate (see Figure 1, bottom right). Accurate ap-
proaches use random sampling, but this becomes arbitrarily expen-
sive for small light sources or features. There is a lack of efﬁcient,
accurate solutions for computing these important types of paths.
In this paper we explicitly solve for refracted paths that connect a
point inside and a point outside the medium. Our contributions are:
• Formulation of the problem based on the half-vector. This is
necessary to support triangles with smooth shading normals,
the most widely used geometry representation in graphics.
• Robust and efﬁcient iterative techniques to ﬁnd all such paths.
• Hierarchical pruning algorithms to scale to large meshes.
• Derivations and methods for computing the light contribution

along a refracted path.

We will next brieﬂy review previous work in Section 2, then formu-
late the problem and describe our path ﬁnding in Section 3. Sec-

tion 4 describes how to compute the light contribution along each
path. Finally, we present results in Section 5.

2 Previous Work
Our algorithm is related to previous work in several areas.
Subsurface scattering. Hanrahan and Krueger [1993] approxi-
mated single scattering by a BRDF, while using a full Monte-Carlo
solution for multiple scattering. Jensen et al. [2001] simpliﬁed the
multiple scattering case with their dipole approximation, but still
use the BRDF approximation or use shadow rays that ignore re-
fraction for single scattering.
Volume scattering. There has been a lot of work on fast volume
scattering in non-refractive media such as Sun et al. [2005] and
Nishita and Nakamae [1987], but this does not generalize easily
to refractive media.
Accurate reﬂections from curved reﬂectors. Several researchers
have used Fermat’s principle to solve for reﬂection points on curved
reﬂectors. Mitchell and Hanrahan [1992] used differential geom-
etry and interval analysis to compute the exact reﬂection points.
They discuss, but do not demonstrate, ﬁnding refraction points.
Chen and Arvo [2000] compute a quick approximation of reﬂected
rays using a Taylor expansion. Both these approaches are restricted
to implicit surfaces with known equations.
Most models used in computer graphics use triangle meshes. Ofek
and Rappoport [1998] computed the reﬂections of the vertices of
such a triangular mesh. In recent work, similar methods have been
used for interactive rendering, e.g. [Estalella et al. 2006; Roger and
Holzschuch 2006; Szirmay-Kalos et al. 2005; Sz´ecsi 2006]. How-
ever these methods ﬁnd the reﬂection point by ray tracing and then
solve for the approximate reﬂected point. This is a different prob-
lem than the one we are solving.
Beam tracing.
The light refracted through the surface can be
represented by a set of volumetric beams, but the beams have com-
plicated shapes and intensity proﬁles. However fast caustic approx-
imations can be constructed by sampling and interpolating intensity
values in these beams, (e.g., [Nishita and Nakamae 1994; Iwasaki
et al. 2003; Ernst et al. 2005]), though these methods are approxi-
mate and have trouble tracking shadowing of the caustics.
Monte Carlo. Caustics can, in principle, be computed by Monte
Carlo path tracing, but the convergence tends to be very slow when
shadow rays cannot be used, such as in refractive single scatter-
ing, especially if the light source is small. Metropolis Light trans-
port [Veach and Guibas 1997] improves the Monte Carlo conver-
gence rate by exploring perturbations about such paths once found,
but still works best when the light source is large or shadow rays
can be used.
Photon mapping. Photon mapping [Jensen 2001; Jarosz et al.
2008] can estimate the light at any point in space, but the result
is blurred by the size of the kernel needed to reduce the noise. Thus
very large numbers of photons can be necessary to reconstruct sharp
features like caustics, especially with participating media. On the
GPU, photon mapping can be done interactively [Sun et al. 2008]
with impressive results for small scenes, but is still very data inten-
sive and requires high photon counts.
Compared to our method, photon mapping handles a wider variety
of lighting paths, with a cost that depends mostly on the ﬁnest fea-
ture resolution one is trying to reconstruct and the spatial extent of
the scene, due to the view-independent nature of the photon map.
Our method is purely view-dependent but handles only a speciﬁc
class of light paths with cost that depends mainly on the medium
boundary complexity and number of distinct convergent light paths.

Figure 2: (a) Multiple paths (black lines) may connect light L
to scatter point V, while the non-refractive approximation (pur-
ple line) cannot account for these paths. (b) Geometry of problem
at a point P with geometric normal ˆNg and shading normal ˆNs.

3 Finding Refracted Connecting Paths
Our goal is to compute the illumination at a point inside a refrac-
tive medium from a light source outside the medium. Speciﬁ-
cally, we want to ﬁnd all the ways that light from a point L out-
side the medium can reach a scattering point V inside the medium
without scattering in between except for a single refraction event
when it crosses into the refractive medium boundary (see Fig-
ure 2). We assume the index of refraction is piecewise constant with
η = ηin/ηout. We also assume that the refraction obeys Snell’s law
except that it may bend relative to the local shading normal ˆNs
instead of the true geometric normal ˆNg.
To solve this problem, we need to ﬁnd all the points P on the bound-
ary which can refract light from L towards V and compute how
much light travels along each such LPV path.
In this section, we ﬁrst present a half-vector formulation of the
problem that can be used with shading normals. Based on this
formulation we then present fast, iterative solution techniques for:
triangles without shading normals (Section 3.2) and with shading
normals (Section 3.3). For the latter, we provide both a basic it-
erative solution that works well in practice and a more expensive
interval-based modiﬁcation that is guaranteed to ﬁnd all solutions.
And ﬁnally, we present efﬁcient hierarchical algorithms to handle
to media with complex triangle mesh boundaries (Section 3.4).

3.1 Half-vector problem formulation

One way to formulate this problem [Mitchell and Hanrahan 1992]
is using Fermat’s principle. Let us deﬁne the optical path length as
η(cid:107)V−P(cid:107)+(cid:107)L−P(cid:107), then the valid solutions for P are the extremal
points (minima and maxima) of this equation under the restriction
that P must lie on the boundary. Or equivalently, the gradient of
this length (as a function of P) must be collinear with the geometric
surface normal ˆNg(P). However Fermat’s principle does not hold
when using shading normals, such as triangles with interpolated
normals or normal maps. Instead we use an alternate formulation
based on the refractive half-vector ˆH [Walter et al. 2007], which
does generalize easily to handle varying shading normals (i.e., the
geometric normal is not equal to the shading normal, ˆNg (cid:54)= ˆNs).
Let us deﬁne a direction (unit vector) ˆH as follows:

ˆωV =

ˆωL =

ˆH =

V − P
(cid:107)V − P(cid:107)
L − P
(cid:107)L − P(cid:107)
η ˆωV + ˆωL
(cid:107)η ˆωV + ˆωL(cid:107)

(1)

(2)

(3)

Then ˆH is collinear with the surface normal at all valid refraction

3.3 Case 2: Triangle with shading normals
When triangles have varying shading normals, the problem is much
harder. Within the plane of the triangle there may be zero, one, or
multiple solutions for P and they need not lie within a single inci-
dence plane, thus requiring a 2D rather than a simpler 1D search.
We use a two stage strategy; we progressively split the triangle into
smaller sub-triangles until they meet some criteria while trying to
prune out sub-triangles that cannot contain a solution. Then we use
2D Newton-Raphson iteration to locate potential solutions in the re-
maining sub-triangles. We ﬁrst describe the 2D Newton-Raphson.
2D Newton-Raphson. One key to the successful use of Newton-
Raphson and fast convergence is deﬁning a good target function
f. If we express the locations on the sub-triangle using barycentric
coordinates (a, b) so that a point is inside the sub-triangle if a ≥ 0,
b ≥ 0, and a + b ≤ 1, then we can express the point, half-vector,
and shading normals as: P(a, b), ˆH(a, b), and ˆNs(a, b) and deﬁne
the target function as:

f (a, b) = ˆH(a, b) + ˆNs(a, b)

(8)

which from Equation 4 must go to zero when P(a, b) is a valid
refraction solution.
Standard 2D Newton-Raphson uses the inverse of the Jacobian ma-
trix J of f. Since our f maps from 2D to 3D, its Jacobian is
a 3 × 2 matrix and not invertible. We tried several approaches
to this problem but by far the best was to use the pseudo-inverse
J + = (J T J)−1J T . The iteration using the pseudo-inverse is:

–

» ai+1

bi+1

–

» ai

bi

=

− J +(ai, bi) f (ai, bi)

(9)

Computing the Jacobian of f involves repeatedly applying the fol-
lowing rule for the derivative of a normalized vector (derived via
the quotient and chain rules from calculus):

ˆn =

(cid:126)u

(cid:107)(cid:126)u(cid:107) ⇒ ˆn

(cid:48)

=

(cid:107)(cid:126)u(cid:107)2(cid:126)u(cid:48) − ((cid:126)u · (cid:126)u(cid:48))(cid:126)u

(cid:107)(cid:126)u(cid:107)3

(10)

To improve stability, we limit the maximum step size per iteration
((cid:107)(cid:52)a,(cid:52)b(cid:107) ≤ 1/2) and replace a step with a smaller step if it fails
to reduce (cid:107)f(cid:107). We use a0 = 1/3, b0 = 1/3 as our initial starting
guess, but if (cid:107)f (a0, b0)(cid:107) > 1 then we also try a few other starting
points and start with the one with the least (cid:107)f(cid:107) instead. Speciﬁcally
we also try the vertices of the sub-triangle and the projection of V
onto the triangle’s plane along the average shading normal. With
these modiﬁcations, we have found the 2D Newton-Raphson works
very well. It nearly always converges when there is a real solution in
the vicinity of the sub-triangle and usually within 3 to 7 iterations.

3.3.1 Split-and-prune for sub-triangle search
Splitting a triangle into 4 smaller triangles is trivial by splitting each
edge; the interesting part of our recursive split-and-prune approach
for smooth normals is how to detect when a triangle cannot contain
a solution and so can be safely pruned from our search. We accom-
plish this by computing bounding cones for directions − ˆH and ˆNs
and then pruning the triangle whenever these cones do not overlap.
For triangles with interpolated normals, all the shading normals
within the triangle must lie within a spherical triangle deﬁned by
the shading normals at the vertices, and it is easy to compute the
bounding cone of a spherical triangle. We do not yet support nor-
mal mapped triangles, but bounding cones could be precomputed
and stored with the normal map in that case.
Computing a bounding cone on ˆH involves a few more steps. Since
(L−P)/(cid:107)L−P(cid:107) and (V−P)/(cid:107)V−P(cid:107) deﬁne two spherical trian-
gles, we compute 3D axis-aligned bounding boxes for each. Then

Figure 3: The setup for a triangle without shading normals which
reduces the 2D search for P to a 1D search in the incidence plane.

points P, since requiring that the components of ˆH perpendicular
to the normal vanish is equivalent to Snell’s law. Assuming the
relative index of refraction η > 1, P is a valid solution to our
refracted path ﬁnding problem if and only if:

and

ˆH = − ˆNs

(V · ˆNg) ≤ (P · ˆNg) ≤ (L · ˆNg)

(4)
which tests that Snell’s law is obeyed relative to the shading normal
ˆNs and that V and L lie on opposite sides of the local geomet-
ric tangent plane. We use the conventions that the normals point
outwards from the refractive object while ˆH points into the denser
medium.
In general there is no analytical solution for this set of equations.
Prior work has focused on iterative solutions for geometric repre-
sentations with nice analytic properties and derivatives such as im-
plicit surfaces [Mitchell and Hanrahan 1992; Chen and Arvo 2000].
However, the most common geometric representations in computer
graphics are triangle meshes, usually with varying shading normals.
These meshes pose different challenges in terms of solving for the
refracted paths and are the focus of this paper.

3.2 Case 1: Triangle without shading normals
For a triangle without shading normals, if V and L lie on the appro-
priate sides of the triangle’s plane, then there always exists a single
solution P in this plane and it must lie in the incidence plane de-
ﬁned by V, L, and ˆNg. Thus, we can solve for P using a 1D search
and then check to see if it lies within the triangle.
Let us work in a coordinate system such that all the relevant points
lie in the z = 0 plane, the triangle lies in the y = 0 plane and
V is on the y-axis so we can express the problem in 2D using:
V = (0, Vy), P = (x, 0), L = (Lx, Ly), and ˆNg = ˆNs =
(0, 1) (see Figure 3). Then we need only search for x such that
ˆH = − ˆNg. Since we already know ˆH and ˆNg lie in the z = 0
plane, this is equivalent to letting f (x) = ( ˆH · (1, 0)), and we can
use the Newton-Raphson iterative method for ﬁnding x such that
f (x) = 0.

f (x) =

x0 =

p(Lx − x)2 + L2

Lx − x

y

−ηxpx2 + V 2

y

−VyLx
ηLy − Vy

+

4

3 + η

(5)

(6)

(cid:48)

(xi)

xi+1 = xi − f (xi)/f

(7)
where x0 is an initial guess for x, f(cid:48) is the derivative of f with
respect to x, and the last equation is the deﬁnition of 1D Newton-
Raphson iteration. We have intentionally omitted the normalization
term of ˆH since overall scaling factors do not affect the locations
of the zeros of a function. We also clamp all xi to the range [0, Lx]
since the solution must lie in this range. Equation 6 is an empiri-
cal heuristic that required fewer average iterations to converge than
other starting points we tried. With these settings, the Newton-
Raphson always converges, and usually in just 2 to 4 iterations.

we scale the second box by η and take their Minkowski sum (which
just adds the corresponding bounding values) to get a bounding box
on the unnormalized version of ˆH. Lastly we compute a bounding
cone for this box which is also therefore a bounding cone on ˆH.
Note that all of our bounding cones have their apex at the origin.
Finally, two cones overlap if the angle between their axes is less
than the sum of their bounding semiangles.
We have tested two strategies for deciding when to stop subdividing
a triangle and run the Newton iteration. The ﬁrst is a quick heuristic
based on the size of these bounding cones; stop if the sum of the
ˆH and ˆNs cone angles is less than thirty degrees. This heuristic
has worked well in our experience, producing visually good results,
but is not guaranteed to ﬁnd all solutions. The second is a more
expensive interval test with strong guarantees described below.

3.3.2 Guaranteed interval-based reﬁnement test
While 2D Newton iteration converges very quickly (quadratically)
once close enough, it may fail to converge even if a solution exists
and only ﬁnds at most one solution even if there may be several
nearby. This can be ﬁxed by subdividing the triangle until we have
starting points sufﬁciently near every solution, but how do we know
when its safe to stop subdividing? The cone angles heuristic (see
above) works well in practice, but if desired we can get stronger
guarantees using interval tests at the cost of some extra subdivision.
Moore and others [Moore 1977; Rall 1981] introduced interval ex-
tensions to Newton Raphson iteration. The original formulation
required inverting the interval Jacobian matrix, which can be non-
trivial. Krawczyk [1969] introduced a formulation which does not
require inverting an interval matrix. This formulation was also used
by [Mitchell and Hanrahan 1992] for reﬂections. We modify this
formulation to work with our 2D Newton iteration and the pseu-
doinverse. Both Krawczyk and Newton Raphson are iterative ﬁxed
points algorithms where the iteration maps a point to itself if and
only if it is a solution to the equation (i.e., xi+1 = xi ⇔ f (xi) =
0). Krawczyk works with intervals allowing reasoning about re-
gions of the search space, but in the limit of degenerate intervals
(single points), it is identical to Newton Raphson.
Let us introduce some notation. f (a, b) = 0 is the equation we
are solving. X = {Xa, Xb} is a 2D interval representation of
our solution space, where Xa and Xb are intervals on a and b re-
spectively. For any triangle all valid values of a and b lie within
the interval [0, 1]. F(X) is the interval representation of f and in-
cludes all possible values that f can take over points in X. F(cid:48)(X)
is the interval representation of the Jacobian matrix. m(X) is an
operator that replaces each interval in X by its midpoint. Let
m0 = m(X) = (ma, mb) = (0.5, 0.5), and M = m(F(cid:48)(X)).
F(cid:48)(X) is a 3×2 matrix of intervals, M is an ordinary (non-interval)
matrix and M+ is the pseudoinverse of M. We compute K(X) as:

K(X) = m0 − M+f (m0) + [I − M+F
(cid:48)

(X)](X − m0)

(11)

A solution, or ﬁxed point, can not exist in the interval X if either of
these conditions is true:

∅ (cid:54)∈ F(X)
K(X) ∩ X = ∅

(12)
(13)

Furthermore, if both of the following conditions are true, then there
is exactly one unique solution in X, and ordinary (non-interval)
Newton iteration will converge to it.

K(X) ⊆ X
||I − M+F
(X)|| < 1
(cid:48)

(14)
(15)

Figure 4: Spindle test. Valid solutions for P must be within the
shaded region in 2D, and within the surface of revolution in 3D.

where the ﬁrst condition requires that the interval maps back to a
subset of itself, and combined with the second condition guarantees
that the interval continues to shrink at each subsequent iteration.
test, we skip sub-
When using the interval-based reﬁnement
triangles if Equations 12 or 13 are true.
If both Equations 14
and 15 are true, then we switch to ordinary 2D Newton iteration
(guaranteed to converge though the solution may lie outside the
sub-triangle). Otherwise, we recursively subdivide our triangle and
keep searching for solutions.

3.4 Scalability to triangle meshes
For meshes with small numbers of triangles, one can simply test
all triangles for solutions, as described above, but to handle larger
meshes we use a hierarchical pruning process to eliminate whole
groups of triangles that cannot contain a solution. We ﬁrst construct
a hierarchy over the triangles called a position-normal tree [Bala
et al. 2003; Snyder 1992]. This is a binary tree where the leaves
are triangles and each node contains a 3D axis-aligned bounding
box over positions and a bounding cone over shading normals that
is valid for all its descendants. We construct this hierarchy using a
bottom-up approach similar to that in [Walter et al. 2005].
To solve for all refractive connection paths through a triangle mesh,
we perform a depth-ﬁrst traversal of the position-normal tree. At
each node we test to see if we can prune out the subtree by proving it
has no solutions using the following three pruning tests: the spindle
test, the sidedness test, and the cone overlap test. We now brieﬂy
describe each of these tests; for more details see [Walter et al. 2009].
The spindle test. A single refraction can only bend the light by a
limited amount. Even for arbitrarily large values of η, the light can
be bent by at most a right angle and for more reasonable η values,
the bending is more restricted. Speciﬁcally the angle between PL
and PV must form an angle between π/2 + arcsin(1/η) and π
in radians. This is only possible if P lies within a region centered
around the line segment VL as shown in Figure 4. This region,
which we call the spindle, is a surface of revolution of a circular arc
from V to L. This shape is a direct consequence of the refractive
bending angle limit and the inscribed-angle theorem for circles.
We have developed a simple test to see if a bounding box may over-
lap this region. Let r be the distance from a point P to the line
containing L and V. Then the point P lies within the spindle if:

(cid:107)L − V(cid:107)

η

r ≤ (cid:107)L − V(cid:107)2

4

+

(16)

‚‚‚‚P − L + V

2

‚‚‚‚2

If η is arbitrarily large, this reduces to a point in sphere test, but
becomes more stringent as η decreases. We use a slightly modiﬁed
standard box-sphere overlap test to test if the box could overlap the
spindle by also computing a lower bound on the distance from the
box to the line containing V and L. This test is cheap to compute
and does not depend on the shading normals, allowing it to prune
many subtrees even if they have large normal bounding cones.
The sidedness test. For a point to be a valid refraction point, L
must lie on the positive side of its shading normal, and V must

lie on the negative side of the shading normal and within a cone
bounded by the critical angle, arcsin(1/η). Using techniques
from [Walter et al. 2005], we compute bounds on the angles be-
tween the axis of the shading normal bounding cone and L and V
as seen from any point in the position bounding box. We then offset
these by the semiangle of the normal bounding cone and see if it is
possible for the respective angles to lie within the required ranges.
The cone overlap test. This test is a simple extension of the prun-
ing test used for pruning sub-triangles in the smooth normal case.
The one difference is that the positions are bounded by a 3D box
rather than a 2D triangle, but the test is otherwise the same.

4 Contribution of Refracted Light Paths
Once we have computed a refracted path connecting L and V
through some point P on the boundary, we need to compute how
much contribution it makes to the illumination. Most of the terms
are similar to the contribution from a regular shadow ray. For ex-
ample, if L is a point light with intensity Ie, F is the fresnel factor
at P, A is the volume attenuation (i.e., integral of σs along the line
segment inside the media), and V is a volume scattering event with
phase function ρ, then the contribution for an unoccluded path is:

contribution =

Ie F A ρ

D

(17)

where D is the distance correction factor discussed below. If the
medium is clear then A = 1. If V is a surface point, then replace ρ
with the BRDF times the cosine of angle with surface normal at V.
If simulating an area light then replace Ie with the emitted radiance
times the cosine of angle with surface normal at L, divided by the
probability of sampling L.
If there is no refraction (η = 1) then we have the usual distance
squared factor, D = (cid:107)L − V(cid:107)2. If there is refraction but we are at
normal incidence without shading normals, ˆωL = ˆNg = ˆNs, then
we get D = ((cid:107)P − V(cid:107) + η(cid:107)L − P(cid:107))2. For the special case of no
shading normals (i.e., ˆNs = ˆNg) the exact equation is:

D = (dV + ηdL)

|ˆωV · ˆNg| dV +

|ˆωV · ˆNg|
|ˆωL · ˆNg| ηdL

(18)

  |ˆωL · ˆNg|

!

with dV and dL deﬁned below.
In the general case of shading normals, D is more complex and does
not seem to have a simple equation. Computing D correctly is nec-
essary to get visually good results that match reference solutions.
First, we compute derivatives for L in the plane perpendicular to ˆωL
with respect to perturbations in ˆωV , which is equivalent to comput-
ing the solid angle of a small area around L as seen from V. This
was inspired by and uses techniques from ray differentials [Igehy
1999]. We compute this differential using the following equations:

!

ˆωV

dV = (cid:107)V − P(cid:107)
dL = (cid:107)L − P(cid:107)
(cid:48)
(cid:48)

 

P

ˆω

= dV

V − ˆω(cid:48)

V · ˆNg
ˆωV · ˆNg
µ = ˆωL · ˆNs + η ˆωV · ˆNs
(cid:48)

!“

 

µ

=

η2 ˆωV · ˆNs
ˆωL · ˆNs
(cid:48)
V + µ
(cid:48) − (P

+ η

V · ˆNs + ˆωV · ˆN
(cid:48)
(cid:48)
s

ˆω

(cid:48)
L = η ˆω
ˆω
(cid:48)
= P
L

(cid:48)
(cid:48) ˆNs + µ ˆN
s
(cid:48) · ˆωL)ˆωL + dL ˆω

(24)
(25)
where we use the notation that a(cid:48) is the derivative of a with respect
to a small perturbation in ˆωV and perpendicular to it. We compute

(cid:48)
L

(19)
(20)

(21)

(22)

(23)

”

model
teapot
cuboctahedron
amber
glass tile
glass mosaic
pool
bumpy sphere

boundary

12
20
36
798
20813
2632
9680

smooth

N
N
N
Y
Y
Y
Y

other
4096

0

60556

60
1450
4324

0

time
15.3s
13.9s
19.2s
66.9s
87.8s
59.4s
304.3s

Figure 5: Results for CPU version of our method on seven models.
Shows the number of triangles in refractive boundaries, whenever
the boundary uses interpolated normals, the number of other trian-
gles in the scene, and time to compute a 512x512 image using 64
samples per pixel (except bumpy sphere used 128 samples).

these derivatives for two different directions perpendicular to ˆωV
and to each other to get L(cid:48)
⊥ and L(cid:48)
(cid:107) and the correct distance factor
from their vector cross product as:
D = (cid:107)L
⊥ × L
(cid:107)(cid:107)
(cid:48)
(cid:48)

(26)

We were surprised by the seeming complexity of D, but have not
managed to ﬁnd a simpler form for it. However, it is not difﬁcult to
code once the equations are known and the only other piece needed
is the ability to compute the derivatives of the shading normal ˆNs
which can easily be computed for triangles with interpolated nor-
mals [Igehy 1999]. For more discussion see [Walter et al. 2009].

5 Results
We implemented our refractive path ﬁnding algorithms in both CPU
and GPU versions. The CPU version is implemented in a Java-
based ray tracer using Sun’s 1.6 server JVM and running on an 8-
core, 2.83 Ghz machine (dual Intel Xeon 5440 chips). All CPU re-
sults are for 512× 512 images with 64 samples per pixel except the
bumpy sphere that used 128. Each eye ray is traced through refrac-
tive or reﬂective bounces until it hits a diffuse or glossy surface or
scatters in a volume (importance sampled according to the volume
attenuation along eye ray). For points inside a refractive medium,
we connect it to the light source using our techniques by ﬁnding all
connecting refractive paths, checking them for occlusion, and com-
puting their contribution. Points outside the medium are shaded us-
ing conventional direct illumination. Results and statistics for our
scenes are shown in Figures 1 and 5. All the refractive media are
homogeneous with η = 1.5. Each scene is lit by one point light
except for the pool which has two small area lights.
The only additional storage required beyond a normal ray tracer is
the position-normal tree, currently about 100 bytes per boundary
triangle in our implementation. The tree build is very fast; for the
glass tile model it takes 6ms and the tree only needs to be rebuilt if
the geometry deforms non-rigidly.
The ﬁrst three models demonstrate faceted refraction without in-
terpolated normals. The teapot embedded in purple glass exam-
ple shows interesting refractive effects even in a very simple con-
ﬁguration with three distinct refractive beams lighting the teapot.
The cuboctahedron shows single scatter volume caustics including
brightening due to beam overlap near edges and vertices. The scor-
pion in amber combines both volume and surface effects.
The glass tile is a piece of rounded glass with a diffuse backing,
modeled with only 798 triangles but with interpolated normals to
simulate a smooth surface. You can see sharp caustics caused by
the focusing of light by the simulated curved surface. The glass
mosaic combines 25 such glass tiles into a more complex shape.
The pool is modeled after a famous image from [Veach and Guibas
1997], but with two much smaller area lights that make the caustics
sharper and much harder to ﬁnd by conventional methods.

photon map

our result

straight-line

path tracing

Figure 6: Glossy teapot embedded in purple glass cube model ren-
dered using photon mapping with 20 000 photons and our result.
The photon map solution shows blurring, light leaks, and other vi-
sual artifacts despite taking twice as long to compute as our result.
Bottom row shows a zoom-in of a region in the result images.

The bumpy sphere is our most challenging model because it focuses
light into surprisingly small, detailed volume caustics in its interior.
The radiance can grow arbitrarily large near focal points or cusps
in such caustics leading to spike noise when sampling the volume
along eye rays, even if the region has little effect on the integral due
to its small size. This noise can be greatly reduced by clamping D
(Equation 26) to be larger than a minimum threshold at the cost of
some energy loss. For this model only, we used a manually chosen
clamping threshold that reduced noise with little energy loss, but
more research is needed in automatic ways to handle such caustics.

We used our cone-angles subdivision heuristic for all result images.
The interval-based reﬁnement test with convergence guarantees is
typically 2 to 5 times slower depending on the scene, while produc-
ing visually equivalent images for these examples. On rare occa-
sions, the heuristic misses a few paths near caustic cusps that the
interval test ﬁnds, but in our results this affects at most a few pixels
and the differences are hard to spot. The position-normal tree and
hierarchical pruning are essential for good performance on bound-
ary meshes with more than a few triangles. For example the pool
scene took 59.4s to render with the reﬁnement heuristic and hierar-
chy, 141.1s with the interval reﬁnement test, and 1934.6s without
hierarchical pruning (slowing down by 2.4x and 32x respectively).

A comparison with photon mapping for the teapot model is shown
in Figure 6. Photon mapping is a versatile algorithm that can sim-
ulate a wider range of light paths than our technique. However the
blurring inherent in its density estimation kernel can cause a variety
of visual artifacts. In this example, even though the photon map im-
age took twice as long as our result, you can see signiﬁcant blurring
of the shadow boundaries, light leaks that coupled with the glossy
BRDF lead to bright speckles, and faceting artifacts caused by dis-
continuities in the photon distribution between facets coupled with
the shading normal modiﬁed BRDF. Typically a ﬁnal gather pass is
used to greatly ameliorate such artifacts, but for single scattering,
this is not feasible as it would degenerate to path tracing.

The bumpy sphere rendered with four different algorithms is shown
in Figure 7. The common approximation of ignoring refraction on
shadow rays is cheap, but eliminates all the visually rich detail in
the image. To get path tracing to work at all on this scene we had
to replace the point light with a small area light and then conver-
gence is very slow. Even after 1.4 hours, the path tracing result is

photon map

our result

Figure 7: Back lit bumpy sphere with four rendering algorithms.
The straight-line approximation cannot capture the volume caus-
tics. Path tracing required replacing the point light with a small
area source and even with 32 768 samples per pixel (compute time:
1.4 hours) produces a very noisy result (white region is a reﬂec-
tion of the area source). The photon map is much better and takes
roughly equal time as our result, but even with ten million photons,
it still blurs out the ﬁner details of the caustics as shown in the bot-
tom row zoom-in. Our algorithm is able to capture these ﬁne details
without the high memory or time requirements of the other methods.

extremely noisy. Bidirectional path tracing would be even less ef-
ﬁcient for the types of paths we are simulating. Photon mapping is
much better, but requires very high photon densities to reduce its in-
herent blurring. In this example, even storing a ten million photons
in the sphere is not enough to resolve the ﬁne detail that you can
see in our result. Photon mapping and our result took roughly equal
time, but our method uses far less memory (hundreds of kilobytes
vs. hundreds of megabytes) and captures ﬁner details.
GPU results. We have also implemented a slightly more limited
GPU version of our algorithm that allows us to achieve interac-
tive performance on several models. The GPU version is written
in CUDA 2.0 and runs on an nVIDIA GTX 280 card with driver
version 181.20. We used a GPU ray tracer based on [Popov et al.
2007] along with the methods described in this paper except that
we do not perform dynamic triangle subdivision on the GPU. Each
GPU thread handles all the tasks for a pixel including ray tracing,
hierarchical pruning, and Newton iteration. Results used 2 samples
per pixel for anti-aliasing, but with multiple volume samples per
eye ray (40 for cuboctahedron and 100 for amber). Timing statis-
tics for our GPU version are in Figure 8. Result images from the
GPU are shown in the accompanying video. A complete version
for Intel’s forthcoming Larrabee platform is also being developed.
Limitations. Our method is designed to ﬁnd refractive connections

model
teapot
cuboctahedron
amber
glass tile

time
0.1s
0.14s
0.3s
6.9s

fps
10fps
7fps
3fps

0.14fps

Figure 8: Results for GPU version of our method on four scenes.

that only cross the refractive boundary once. Thus while it works
well for many caustic effects inside a medium, there are other caus-
tic effects it cannot compute such as the caustic a glass object casts
on a table. Our method is easily extended to simulate low-order
scattering by continuing the eye rays, but is not a good way to com-
pute higher-order scattering such as in the diffusion regime where
other more appropriate approximations exist. Our method assumes
the index of refraction is constant inside the medium (e.g., most
glass or water but not a hot air mirage) though other volume prop-
erties such as the scattering coefﬁcients could be inhomogeneous.

6 Conclusions
We have presented an accurate and efﬁcient solution for solving for
single scattering in a refractive medium. This is an important class
of light paths which are often neglected or approximated simplisti-
cally, due to the difﬁculty of solving these paths accurately and due
to the relative lack of general solution methods.
Our techniques explicitly solve for paths connecting two points:
one inside a refractive medium and the other outside. We present a
formulation of this problem that can handle triangle meshes with in-
terpolated, or otherwise perturbed, shading normals. We introduce
techniques to solve for paths through individual triangles and hier-
archical culling techniques to handle larger meshes without needing
to test every triangle. We have also presented an exact method to
compute the contribution along each such refracted path. Our paper
allows us to compute single scattering in refractive media efﬁciently
without sacriﬁcing accuracy.
We believe our work can be extended to enhance Monte Carlo algo-
rithms such as bidirectional path tracing by allowing them to con-
nect subpaths in different media thus allowing them to more efﬁ-
ciently ﬁnd these types of problematic paths. Our work could also
be used to compute reﬂective caustics with a small change in def-
inition of the half-vector and pruning tests. It is also possible to
extend the method to ﬁnd paths that cross more than one refractive
boundary. However this would greatly expand the search space and
better culling methods would be needed to make this practical.

Acknowledgements This work was supported by NSF CAREER 0644175,
NSF CPA 0811680, NSF CNS 0615240, NSF CNS 0403340, and grants
from Intel Corporation, NVidia Corporation, and Microsoft Corporation.
This work was started while N. Holzschuch was on a sabbatical at Cornell,
funded by INRIA, and he’d like to acknowledge the INRIA CIPRUS asso-
ciate team. LJK is UMR 5224, a joint research laboratory of CNRS, INRIA,
INPG, U. Grenoble I and U. Grenoble II.

References

ESTALELLA, P., MARTIN, I., DRETTAKIS, G., AND TOST, D.
2006. A gpu-driven algorithm for accurate interactive reﬂections
In Rendering Techniques 2006 (Proc. EG
on curved objects.
Symp. on Rendering).

HANRAHAN, P., AND KRUEGER, W. 1993. Reﬂection from lay-
ered surfaces due to subsurface scattering. In Computer Graph-
ics Proceedings, ACM SIGGRAPH, Annual Conference Series,
165–174.

IGEHY, H. 1999. Tracing ray differentials. In Computer Graph-
ics Proceedings, ACM SIGGRAPH, Annual Conference Series,
179–186.

IWASAKI, K., DOBASHI, Y., AND NISHITA, T. 2003. A fast ren-
dering method for refractive and reﬂective caustics due to water
surfaces. Computer Graphics Forum 22, 3 (Sept.), 601–610.

JAROSZ, W., ZWICKER, M., AND JENSEN, H. W. 2008. The
beam radiance estimate for volumetric photon mapping. Com-
puter Graphics Forum (Proc. Eurographics ’08) 27, 2.

JENSEN, H. W., MARSCHNER, S. R., LEVOY, M., AND HANRA-
HAN, P. 2001. A practical model for subsurface light transport.
In Computer Graphics Proc., ACM SIGGRAPH, Annual Conf.
Series, 511–518.

JENSEN, H. W. 2001. Realistic Image Synthesis Using Photon

Mapping. AK Peters.

KRAWCZYK, R. 1969. Newton-algorithmen zur bestimmung von

nullstellen mit fehlerschranken. Computing 4, 3, 187–201.

MITCHELL, D., AND HANRAHAN, P. 1992.

Illumination from
curved reﬂectors. Computer Graphics (Proc. of Siggraph) 26, 3,
283–291.

MOORE, R. E. 1977. A test for existence of solutions for non-linear
systems. SIAM Journal on Numerical Analysis 14, 4, 611–615.

NISHITA, T., AND NAKAMAE, E. 1994. Method of displaying
optical effects within water using accumulation buffer. In Com-
puter Graphics Proceedings, ACM SIGGRAPH, Annual Con-
ference Series, 373–379.

NISHITA, T., MIYAWAKI, Y., AND NAKAMAE, E. 1987. A shad-
ing model for atmospheric scattering considering luminous in-
tensity distribution of light sources. Computer Graphics (Proc.
of Siggraph) 21, 4, 303–310.

OFEK, E., AND RAPPOPORT, A. 1998.

on curved objects.
SIGGRAPH, Annual Conference Series, 333 – 342.

Interactive reﬂections
In Computer Graphics Proceedings, ACM

POPOV, S., G ¨UNTHER, J., SEIDEL, H.-P., AND SLUSALLEK, P.
2007. Stackless kd-tree traversal for high performance gpu ray
tracing. Computer Graphics Forum 26, 3 (Sept.), 415–424.

RALL, L. B. 1981. Automatic Differentiation: Techniques and
Applications, vol. 120 of Lecture Notes in Computer Science.
Springer.

BALA, K., WALTER, B., AND GREENBERG, D. P. 2003. Combin-
ing edges and points for interactive high-quality rendering. ACM
Transactions on Graphics 22, 3, 631–640.

ROGER, D., AND HOLZSCHUCH, N. 2006. Accurate specular
reﬂections in real-time. Computer Graphics Forum (Proc. of EG
2006) 25, 3.

CHEN, M., AND ARVO, J. 2000. Theory and application of spec-
ular path perturbation. ACM Transactions on Graphics 19, 4,
246–278.

ERNST, M., AKENINE-M ¨OLLER, T., AND JENSEN, H. W. 2005.
Interactive rendering of caustics using interpolated warped vol-
umes. In Graphics Interface 2005, 87–96.

SNYDER, J. M. 1992.

Interval analysis for computer graphics.

Computer Graphics 26, 4 (July), 121–130.

SUN, B., RAMAMOORTHI, R., NARASIMHAN, S. G., AND NA-
YAR, S. K. 2005. A practical analytic single scattering model
for real time rendering. ACM Transactions on Graphics 24, 3,
1040–1049.

SUN, X., ZHOU, K., STOLLNITZ, E., SHI, J., AND GUO, B. 2008.
Interactive relighting of dynamic refractive objects. ACM Trans-
actions on Graphics 27, 3 (Aug.), 35:1–35:9.

SZ ´ECSI, L. 2006. The hierarchical ray engine. In WSCG (Winter

School of Computer Graphics).

SZIRMAY-KALOS, L., ASZ ´ODI, B., LAZ ´ANYI, I., AND PRE-
MECZ, M. 2005. Approximate ray-tracing on the GPU with dis-
tance impostors. Computer Graphics Forum (Proc. Eurograph-
ics ’05) 24, 3.

VEACH, E., AND GUIBAS, L. J. 1997. Metropolis light transport.
In Computer Graphics Proceedings, ACM SIGGRAPH, Annual
Conference Series, 65–76.

WALTER, B., FERNANDEZ, S., ARBREE, A., BALA, K.,
DONIKIAN, M., AND GREENBERG, D. P. 2005. Lightcuts: A
scalable approach to illumination. ACM Transactions on Graph-
ics 24, 3 (Aug.), 1098–1107.

WALTER, B., MARSCHNER, S. R., LI, H., AND TORRANCE,
K. E. 2007. Microfacet Models for Refraction through Rough
In Rendering Techniques (Proc. EG Symposium on
Surfaces .
Rendering), 195–206.

WALTER, B., ZHAO, S., HOLZSCHUCH, N., AND BALA, K. 2009.
Supplemental to single scattering in refractive media with tri-
angle mesh boundaries. Technical Report PCG-09-01, Cornell
Program of Computer Graphics, June.

