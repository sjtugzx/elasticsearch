A  Protocol 

to  Maintain 

a  Minimum 

Spanning 

Tree 

in  a  Dynamic 

Topology 

* 

C.  Cheng, 

I.A.  Cimett, 

and  Srikanta  P.R.  Kumar 

Electrical 

Engineering 

and  Computer 

Science  Department 

Northwestern 
Evanston, 

University 
IL  60208 

Abstract 

We  present  a  distributed 
a  minimum-weight 
with 

changing 

protocol 

for  updating 

spanning 

tree 

(MST) 

topology. 

The  protocol 

and 
in 
can 

to  multiple 

link/node 

failures 

can  occur  at  arbitrary 
finite  number 

of  topological 

times.  Given 

the  protocol 

network, 

The  message 
h w  en 
occur,  where 

links, 

within 

finds 

the  MST 
finite 
complexity 

link 
k 
IV1  and 
respectively. 

recoveries 
[El  are 

and 

recoveries 
that  an  arbi- 
changes  occur  during 
to 
last 
is 
link 
number 

corresponding 
the 
protocol 
and  m 
total 

time 
of 

after 

the 

the 

maintaining 
a  network 
respond 
that 
trary 
a  period, 
the 
change. 
O(+l+klW 
failures 
of  nodes  and 

latest 

1. 

Introduction. 

A 

spanning 

tree 

a  minimally 

represents 
all 
the  nodes 
in  point-t-point 
casting 
ascertain 
termination) 
local-area 
multihop 

[8], 

in 

the  network. 
networks 

in  selecting 

certain 

conditions 
[9].  Spanning 

Such 

of  a  communication 
connected 
structure 

network 
containing 
trees  are  employed 
for  efficient  message  broad- 
to 
or 
in 
in 

trees  have  also  been  used 
[12]  and 

(e.g.:  mutual 

processor 

a  ‘leader’ 

exclusion 

routing 

[lo], 

or 

networks 

for  gateway 

radio  networks 

for  bandwidth 

a  cost  or  weight 
fees  or  delay) 

is  associated 

with 

allocation 
(representing, 

[5]. 

In  general, 
usage 
the 

network. 

example, 
links 
of 
whose  edges  have  minimum 
the 
Minimum-Weight 

tasks  mentioned 

Spanning 

Therefore, 
weight 
This 

above. 

the 
is  usually 
tree 

spanning 

needed 

is  called 
(MST).  One  of 

Tree 

for 
the 
tree 
in 
the 
the 

*  This  work  was  supported 

in  part  by  grants  from  US-WEST 

Advanced  Technologies, 

and  from  Bell  Northern  Research. 

fee all  or  part  of  this  material  is granted  provided 
for  direct  commercial  advantage, 

Permission  io  copy  without 
that  the  copies  are  not  made  or  distributed 
the  ACM  copyright  notice  and  the  title  of  the  publication  and  its  date  appear, 
and  notice  is given  that  copying  is by  permission  of  the  Association 
Computing  Machinery.  To  copy  otherwise,  or  to  republish,  requires  a fee and/ 
or  specific  permission. 

for 

for 

point-to-point 

as  the  GHS  protocol) 
[ll]. 

and  Spira 

in 

the  GHS  protocol 

II&works 
was  presented 
In  a  network 
transmits 

MST 

denoted 

Humblet, 

protocols 

first 
(hereafter 
by  Gallager, 
of  n  nodes  and  e  edges, 
O(nlogn+e) 
uses  O(nlogn) 
protocol 

messages,  with  O(logn) 

bits/message, 

time  units. 
has  been  recently 
the  most  part,  protocols 

(The 
improved 

For 

time  complexity 
(2,  4,  lo]). 

run  over  a  communi- 

and 
of  this 

changing 

topology. 

additions 
the  course  of 

and  deletions 

time. 

Hence,  many 

past 

in  spite  of  topological 
the 
called 
protocol 

resilient 

decade 

the  MST 

for 

or 

The  changes 

in 
of  nodes  and 

protocols 
changes  have 
[1,  6,  131). 
In  par- 
was 

problem 

(e.g.: 
reliable. 

entail 

to  run 

cation  network  with 
topology 
links  over 
that  are  able 
been 
designed 
These  protocols 
ticular, 
proposed 
In 

a  resilient 
in  171. 

in 
are 

this  paper,  we  present 

a  new 

in 

time 

it  will  be  shown 

(i.e.:  a 
is  being 

to  topological 
recoveries, 

of  topological 
a  period 

buted  MST  protocol.  Given 
col  responds 
lfailures 
and 
failures/recoveries 
overlap 
while 
another 
finite  number 
times  during 
period), 
the  MST 
finite 
link 
0(  kn+me) 
trast, 
struct 
sage 
O(logn) 
more 
MST 
with  O(e)  bits/message. 

if  one  uses  a  protocol 
the 
complexity 

corresponding 
the 
and  k 
messages, 

tree  after  every 

efficient 
protocol 

time 
failures 

bits/message. 

last 
link 

after 

will 

to 

an  initial  MST, 

changes  caused  by 

resilient 

distri- 
the  proto- 
link/node 
the  MST.  Multiple 

and  updates 

simultaneously 
can  occur 
failure 
recovery 
or 
processed). 

Assuming 

or 

can 
can  occur 
a 

that 

changes  occur  at  arbitrary 

(and  no  more  changes  after 

this 
the  protocol  will  obtain 
latest  network 

that 
the 

topological 
recoveries, 

each  with  O(logn) 

failure 

(such  as  GHS) 
or  recovery, 
be  O((m+k)*(nlogn+e)), 
presented 
than 

the 

uses  O((m+k)*n) 

The  protocol 
for  dense  networks 
in 

[7]  which 

within 

a 
change.  Given  m 
the  protocol 
uses 
In  con- 
to 
recon- 
the  mes- 
with 

bits. 

is 

herein 
resilient 
messages 

The  paper 

is  organized 

as  follows. 

The  distributed 

computation 
Section 
theoretic 
buted 

and 

2.  Section 
properties 

communication 
3  ‘expiains 
and 

model 

the 

underlying 

are  given 

in 
graph 
of  the  distri- 
the 
resilient 

the  main 
Section 

features 
4  describes 

implementation. 

o 

1988  ACM  O-89791-279-9/88/008/0330 

$1 SO 

t  LA.  Cimet  was  with 

the  EECS  Dept.,  Northwestern 

ty.  He  is  now  with  AT&T  Bell  Laboratories, 

Naperville, 

Universi- 
IL,  60566. 

330 

MST  protocol.  Section  5  presents  a  sketch  of  I IIC proof 
of  correctness.  Finally,  Section  6  contains 
the  complex- 
ity  analysis. 

2.  Computational 

Model. 

is 

identity 

number, 

involving 

where  V 

for  the  protocol 

The  environment 

is  a  computing  unit 

queue  with  unlimited 

(u,v),  assigned  with  a  weight  w(u,v), 

is  an  asynchrc+ 
represented  by  an  undirected  weighted 
the  set  of  nodes  and 
is  the  set  of  links.  Each  node,  assigned  with  a 

nous  network 
graph  W,E), 
ECVXV 
unique 
a  processor,  a  local  memory,  and  also  an  input  queue 
capacity.  Each 
and  an  output 
link 
is  a  bidirec- 
line  connecting  nodes  u  and  v. 
tional  communication 
(the  iden- 
Each  node  knows  only 
its  local  environment 
tity  and  the  weights  of  its  links)  and  follows 
the  same 
protocol  which  consists  of  sending  and  receiving  mes- 
sages  over 
these 
messages.  The  received 
in  the 
input 
basis,  and 
are  also  processed  in  that  order. 

links,  and  processing 
(sent)  messages  are  put 

queue  on  a  first-in-first-out 

the  adjoining 

(output) 

link 

and 

the  link 

transmitted 

is  functioning, 

A  communication 

transmission.  When 
independently 
they  arrive  at 

in  a  dynamic  network  has 
the  following  properties.  Messages  can  only  be  sent  and 
received  over  a  link  which 
is  functioning.  However,  a 
message  need  not  arrive  at  the  receiver,  as the  link  may 
fail  during 
in  both 
messages  can  be 
the  other  end  after  a 
directions, 
in 
finite 
fails  or  recovers,  both  ends 
sequence.  Whenever  a  link 
finite 
the 
are  notilied 
in 
the  time  when  a  link  recovers,  there  are 
same  time.  At 
it,  nor  are  there  mes- 
no  messages  in 
sages  waiting 
to  be  sent  over  it  (i.e.,  all  messages  sent 
out  for  transmission  on  a  link  are  deleted  after  the  link 
fails).  Observe  that 
these  properties  are  commonly  used 
in  the  literature 

time  but  not  necessarily  at 

delay,  without 

(see  [  1,  131). 

undetermined 

through 

transit 

error 

and 

3.  The  Resilient 

MST 

Protocol. 

a 

of 

of  all 

a  finite 

Assume 

that  a  graph  G(V,E) 
its  MST.  Furthermore, 

the 
finite 

find,  within 

links 
number 

change,  an  MST 

along  with 
weights 
Thereafter, 
recoveries  occur  at  arbitrary 
col  must 
logical 
graph. 
Definition 
cal  change  in  the  network,  where 
ti 
the  change  occurs  and  ei  is  the  link 
ers  at 
recovery,  and  Ei,,=Ei-{ 
E,=E. 

Let  Ei+,= 
ei } 

3.1:  Let  Ci =<ei 

define  Vi 

Similarly, 

time. 

that 

is  given 
suppose 

initially 
that 

are  distinct 

(see 
failures 

the 
[ll)). 
and 
times.  The  resilient  proto- 
the  last  topo- 
to 
latest 

time  after 
corresponding 

link 

the 

,ti  >  be  the  i-th 

topologi- 
is  the  time  when 
fails  or  recov- 
is  a 
is  a  failure,  with 
to  be  the  set  of  nodes  in 

that 
EiU{ei} 

if  Ci 

if  C; 

the  graph  after  Ci.  Then 
the 
Si  =G(  Vi  ,Ei  ). 

topological 

i-th 

the  surviving 
change 
is 

net,ulork  after 
denoted 
by 

Suppose  that  only  k  topological 

the  network.  Then, 
an  MST 

for  Sk . 

the  distributed 

changes  occur 

in 
algorithm  must  find 

Properties. 

3.1.  Underlying 

Graph 
Before  the  distributed 

Theoretic 
implementation 

is 

in 

involved 

responding 

is  described, 
link 
we  outline  what 
theoretic  proper- 
failures  and  recoveries,  and  the  graph 
ties  underlying 
These 
properties  will  be  the  basis  for  the  collective  action  of 
the  nodes  involved 
process.  For 
notation  will  be  adopted. 
convenience, 
the 
Given  a  tree  T, 
denote 
the  deletion  and  addition  of  edge  e to  T. 

following 
let  T-e  and  T+e 

in  a  failure/recovery 

the  reconstruction 

of  the  MST. 

respectively 

to 

this 

link, 

then 

fails. 

If  e  is  a  non-tree 

First,  consider  a  single 

then  T’=T 
is  needed.  Conversely, 
two 

failure.  Let  T  be  the 
link 
to  the  failure,  and  let 
MST  of  the  graph  G(V,E)  prior 
link 
T’  be  the  MST  of  G(V,E-{e}),  where  eEE  is  the 
and  no 
that 
if  e  is  a 
updating  of  the  MST 
tree  link, 
fragments 
T  r  and  T,.  These  two  fragments  must  be  reconnected, 
if  at  all  possible, 
observed 
weight 
(see  (71).  (If 
then 
nected). 

the  new  MST. 
where  e’  is  the  minimum 
link  connecting  a  node  in  T  1  to  a  node  in  T, 
T  r  and  T,, 
is  discon- 

is  no  link  connecting 

failure  splits  T  into 

that  T’=T-e+e’, 

the  graph 

It  can  be 

to  obtain 

resulting 

failure 

there 

from 

the 

the  MST 

for  the  moment), 

(assume  no  recoveries, 

graph.  Hence,  starting 

Now,  when  there  are  many,  possibly  simultaneous, 
the  ini- 
is  broken  down  into  many  fragments.  Each  of 
is  also  a  fragment  of  the  MST  of  the 
these  frag- 
for  the  final  graph  can  be  constructed 
these  fragments,  whose 
of 
later)  will  be 

failures 
tial  MST 
these  fragments 
final  surviving 
ments, 
by  finding 
weight 
the  response 
based  on  this  idea,  and  being  so,  this  part  of  the  proto 
the  fixed-topology  MST 
co1 has  many  similarities  with 
there  are  some  impor- 
protocol  of  GHS  (111.  However, 
tant  differences,  and 
the  next 
section. 

is  minimum.  The  distributed 

the  links,  connecting 

these  are  explained 

implementation 

(described 

failures 

from 

link 

to 

in 

To  understand 

the 

consider  a  single 
the  recovered 
T’=T+e. 
then 
this 
graph, 
with 

the 
the  existing 

there 
recovery). 

then 

recovery. 
is  not 

link 

(If  both  ends  are  not 
is  no  spanning 

response 

to  a  link 

the  original  graph, 

recovery, 
If  one  of  the  end  nodes  of 
in 
then 
in  the  original  graph, 
from 
the  original 
forms  a  unique  cycle 
following 

for  the  graph  resulting 

proposition 

If  both  end  nodes  are  in 

recovered 
tree  links.  The 

link 

331 

initiates 

of  a  link 

to  update 

final  MST.  Each  of  the  end  nodes  detecting 

or  across  fragments,  and  the  appropr;;,  t.e cycle 
within 
the  fragment  and  obtain 
has  to  be  identified 
the 
the 
a  response  process, 
failure/recovery 
involve  several  other  nodes  in  the  task  to  be 
which  will 
in 
accomplished.  Such  response  processes  may  overlap 
in  more  than 
the  sense  that  a  node  may  be  involved 
one  of  them  at  the  same  time.  Before  we  present 
the 
description  of  the  protocol,  we  briefly  outline  some  of 
the  main  features  of  each  of  the  response  processes  and 
their 

interaction. 

3.2.1.  Response 

to  a  Link  Failure 

A 

[ll]. 

the 

the 

[ll]). 

(see 

arise 

failure 

failure 

identity 

fragment 

fragment 

to  which 

response 

in  nature 

the  initiated 

In  changing 

in  attempting 

issue  concerns 

first  assign  a  unique 

The  response  to  a  link 

the  failures  break  the  MST 

to 
node  belongs.  That 

fixed-topology  GHS  algorithm 
first 

topology  distributed  MST  algorithm 
initiated 

is  based  on  the  frag- 
to  the 
of  the  GHS 
by  a  node 
the 
is 
the  ingoing  and  outgoing  edges 
the  minimum  outgoing  edge 
topology 
into  several 
to 
to  this  con- 

ment  expansion  notion,  and  is  similar 
fixed 
protocol 
should 
fragment 
necessary  to  distinguish 
of  the  fragment,  and  find 
of 
environments, 
fragments.  Several  difficulties 
modify 
text.  The 
When  a  tree  link  e=(u,v) 
two 
fragments  are  formed  both  of  which  must  have  separate 
is  to  assign  the  identities 
identities.  A  natural 
(w(e),u)  and  ( w  e  v 
fragments  which  contain 
(  1,  1 
node  u  and  node  v,  respectively.  As  link  weights  and 
this  will 
node  identities 
suffice.  However, 
to 
two 
the  same  fragment 
nodes  in  separate 
these 
identity, 
at  the 
time  when 
nodes  is  tested 
and  thus,  a 
(to  see  if 
it 
to 
correct  MST  may  not  result. 
it 
situation 
see  that 
the 
assignment  of  fragment 
is  baaed  on  only  a  part 
(i.e.,  node  identities  and  link  weights  of 
of  the  fragment 
any  proper  subset  of  the  fragment). 

the  edge  connecting 
is  outgoing), 
In  fact, 

this  assignment  may 
fragments  having 

the  same  undesirable 
identity 

is  not  hard 
results 
if 

thought 
to 
the 

are  distinct, 

a  fragment, 

fails  within 

one  might 

fragment 

identity. 

think 

lead 

the 

There 

are 

two  ways 

to  avoid 
distinct 
first  approach 

situation 

the 
identities 
is  to 
let 

fragment.  With 

for 
described  above,  and  maintain 
the 
fragments.  The 
different 
identity  be  the  set  of  node  identities  of  all  the 
fragment 
that 
two 
nodes 
in 
identi- 
nodes  in  different 
ties  when 
them.  This 
testing 
approach  has  been  used  in  a  similar  problem  by  Segall 
the  message  size 
in  (131.  However,  with 
and  the  overall  bit  complexity  will 
increase,  as  a  sub- 
stantial  number  of  messages in  the  resilient  MST  proto- 
col  will  contain 

fragments  will  have  different 

the  edge  connecting 

this  assignment, 

this  approach 

the  fragment 

identity. 

e=(u,v) 

indicates  how  the  new  MST  can  be  obtained. 
Proposition 
pose 
link 
G(V,EU{e}) 
the 
that 
belong  to  V,  then  T’=T+e. 

3.1:  Let  T  be  the  MST  of  G(V,E).  Sup- 
of 
where  e’  is 
the  edges 
If  one,of  u  and  v  does  not 

is 
then  T’=T+e-e’ 

the  maximum  weight  among 

link  with 
form 

the  cycle  in  T+e. 

and  u,v~V, 

the  MST 

recovers. 

If  T’ 

recoveries, 

(as  in  Fig, 

In  order  to  extend 

l), 
3.1  must  be  first  applied 

if  the  cycles  formed  by  T+e 
If  the  cycles  overlap 

position  3.1  to  handle  many  simultaneous 
is  necessary  to  sequentially  apply 
Proposition. 
To  see this,  consider 
e 1  and  es.  The  rule  can  be  applied 
only 
joint. 
in  Proposition 
recoveries  and  then  the  remaining 
ceased on  the  resulting  graph.  The  order  in  which 
recoveries  are  processed 
Moreover, 
within 
it  forms  a  cycle  with  some  of  the  tree  links 
ment.  The  new 
above  rule 
MST). 

the  approach  suggested  by  Pro- 
it 
the  rule  given  by  this 
the  recovery  of  links 
to  both  recoveries 
I  and  T+e  z  are  dis- 
then 
the  rule 
to  one  of  the 
recovery  may  be  pro- 
these 
(see  131). 
recoveries 
recovers  within  a  fragment, 
in  the  frag- 
the 
final 

to 
(a  subtree  of  the 

important 
to 

is  also  a  fragment 

is  also  applicable 

derived  according 

fragments. 

fragment 

If  a  link 

is  not 

rule 

this 

w 

el 

Fig.  1 

e2 

The  properties  described  above  provide  a  basis  for 
features  of  which 

the  main 

the  resilient  MST  protocol, 
are  explained 

in  the  next  section. 

3.2.  Main 
mentation. 

Features 

of  The  Distributed 

Imple- 

In  a  changing  network  environment, 
and  recoveries  can  occur  simultaneously, 
can  occur  when  another  event 
any  moment, 
have  to  be  eventually 

link 
failures 
or  one  event 
is  being  processed.  At 
that  will 
combined.  Recoveries  can  happen 

there  can  be  several 

fragments 

332 

after 

) 
its 

approach 

immediately 

fails.  Then, 

An  alternative 

failure,  assign 

to  the  fragment 

to  the 
(w(e),v,k(e)) 

the 
node  u,  and 

identity.  Specially,  suppose 

is  to  have  a  counter 
times 

for 
the 
this  counter 
link 
if  k( e  is  the  counter  value  of  this 
identity 

each  link,  which  keeps  track  of  how  many 
link  has  failed  and  recovered,  and  attach 
value 
e=(u,v) 
link 
fragment 
(w(e),u,k(e)) 
the 
to 
identity 
node  v.  This  would  ensure 
identity 
fails.  Unfortunately, 
without 
the 
topological 
still  be  viable 
that  are  good  enough 
Notice 
fragment 
approach 

containing 
the 
containing 
that  a  new  and  distinct 
time  a  link 
cannot  be  bounded 
some  assumptions  on  the  time  or  the  order  of 
this  approach  may 
large  counters 
intervals. 
the 
first 

for  reasonably 
for 
the  messages  containing 
the 

identity  will  be  IV1  times 
than  with 

for  a  fragment  every 
the  counter 

changes.  However 

long  operating 

is  generated 

the  size  of 

the  second. 

in  practice 

fragment 

larger 

that 

in 

The  resilient  MST  protocol  described 

in  the  next 
section  could  be  used  with  either  one  of  the  approaches 
described  above  for  assigning  fragment 

identities. 

3.2.2. 

Response 

to  Link  Recovery. 

to 

the 

from 

have 

the  way 

recovers, 

identities. 

trees)  all 

When  a 

(note  that 

link  e=(u,v) 

the  appropriate 

is  denoted  as  the 

two  of  its  descendant 

receives  messages  corresponding 

in  the  cycle,  takes  action 
the  MST. 

then  both  end 
fragment 
If 
nodes  u  and  v  exchange 
their 
then  each  node  initiates 
both  are  in  the  same  fragment, 
a  process  to  find  the  maximum  weight  edge  in  the  cycle 
fragments 
by  propagating  a  message  upward 
to  the  root  of  the 
will  be  directed 
fragment.  The  messages  from  u  and  v  will 
‘meet’  at  a 
least  common  ancestor 
node,  which 
lca(u,v)  will  be  the 
(lea)  of  u  and  v.  In  other  words, 
node  which 
the 
(or  child) 
same  recovery, 
nodes.  This  node,  which  will 
information 
to 
about  the  maximum  weight 
If 
delete  and  insert 
fail) 
the  cycle  is  intact 
the  recovery  process,  the  goal  of  this  pro- 
throughout 
that  when  several 
ces  will  be  accomplished.  Observe 
the  same  fragment 
recoveries  occur  simultaneously 
in 
then  each 
and 
of  the 
recovery  process  can  be  performed 
their  processing 
if  the  cycles  overlap, 
others.  However, 
in  the  following  manner.  When  a  node 
is  sequentialized 
it  does  not  for- 
is  involved 
ward  messages  received 
its  descendants)  about 
other  recoveries.  Such  a  node  stores  the  messages  until 
the 
time 
one  of  the  stopped  messages will  be  forwarded  upwards. 
journey 
recovery 
deadlock  situation  may  occur. 

their 
the  root,  could  get  stopped  by  other 

towards 
processes,  a  potential 

recovery  process  is  completed  at  which 

As  messages  of  one  recovery,  on 

in  processing  one  recovery, 

in  the  cycle  do  not 

cycles  are  disjoint, 

the  corresponding 

independently 

(i.e.,  links 

(from 

links 

first 

into 

recovery, 

lea(e)  and 

forward  at 

to  Fig  2,  both 

in  recovery  processing  will 

(Referring 
lca(e’)  will  not 
receive  messages on  one  side  of  the  cycle).  As  each  node 
involved 
least 
one  recovery  message,  the  root  of  the  fragment  will  be 
informed  of  at  least  one  recovery.  The  root  will  select 
for  processing,  by  sending  a, 
the  first  arriving 
the  same 
privilege  message  which 
path  on  which 
the 
to  release  the  stopped  messages.  (In  Fig.  2,  the 
cycle 
travel 
privilege  will 
to  v 
the  stopped  message  at  x).  After 
and  upwards 
releasing 
is  informed  of  the  com- 
the  cycle  is  updated, 
the  root 
the  recovery  pro- 
pletion. 
cessing  also  avoiding  any  deadlock.  More 
implementa- 
tion  details  are  given  in  section  4. 

recovery  message arrived  and  around 

the  root  sequentializes 

travels  down  over 

to  u,  and  then 

the  root 

Thus, 

from 

Fig.  2 

3.2.3. 
cess. 

Interaction 

of  Failure 

and  Recovery 

Pro- 

F  can  be 

A 

fragment 

outgoing  edge  and  concurrently 

minimum 
or  more  link 
As  long  as  no  tree  link 
complete  and  update  the  fragment  correctly. 

finding 
its 
process  one 
it,  as  described  earlier. 
in  F  fails,  all  the  processes  will 

recoveries  within 

involved 

in 

A  note  of  caution 

is  in  order.  A  node  should  not 
for  its 
consider  any  of  its  recovered  links  as  a  candidate 
is  engaged  in  testing 
minimum  outgoing  edge  when 
in  the  MST  being 
its  outgoing  edges,  as this  may  result 
in  Fig.  3,  links  e r  and  es  may 
incorrect. 
be  included 
if  recovered 
links  are  not  con- 
sidered,  whereas  e e should  be  included 

(For  example 
in  the  MST 

instead  of  es.) 

it 

When 

in  F  fail, 

tree  links 

then  each  new  fragment 
generated  can  again  process  the  failures  and  recoveries 
in  F  causes  the  nodes  u 
within 
and  v  of  a  link 
to  be  in  two  different 
then  the  recovery  process  of  e will  stop  until 
fragments, 

recovery  e=(u,v) 

it.  If  a  tree  link 

failure 

333 

a  REIDEN-ACK<id> 

with 

responds 

node 
which  will  be  sent  upwards 
ment 
root 

root.  When 
then  all  nodes  know 
To 

the  minimum 

to  the 

find 

from 

the 
this  message 
the  current 

outgoing 

message 
frag- 
the 

by 

leaves  of  the 
is  received 
fragment 
edge, 

identity. 
the 

root 

fifind  state  and  performs 
in  which 

the 

root  broadcasts 

another 

broadcast- 
a  FINDMOE 

fragment. 
into 

A  node 
find 

and 
message  over  each  of  its  non-tree 

state 

the 

receiving 

receives  such  a  message  may 
a  REJECT<id>, 

or  with 

this  mes- 
sends 
a 
links.  A 
respond  with  an 
which 
indi- 
is  outgoing. 

or  not 
id  sent  with 

response, 

the  non-tree 

link 

as  the 

the  TEST  message  must  be 
the 
is  the  same 

id  may  change 
The 

reason 

in 

failures. 

id  to  the  echo  in  every  broadcast-echo 
its  parent 

the  echo,  node  u  sends 

to 

>  message 

,  where  w, 

the  outgoing 

edge 

found 

by 

a  node  sends 

this  message 
root 
receives 

state.  When 

message 

from  all 

the 
its  children 

the  minimum 

outgoing 

edge 

this 

over 

root 

point 

the 
the  path 

that 
changes  occur, 
similar 

in  a  manner 

topological 

the  end  node  of  the  moe  receives 

a 
is  the 
the 
it 
a 

sends 

it  knows 
(or  moe)  of 
a 
to  the 

leads 
the 
resilient 
to  the  GHS 
the 
message 

fragments 

fragment 

to 

fragments, 

time  due  to  other 

in 

the 

the 

that 

also 

the 
the 

the 
enters 

enters 
with-echo, 
message  over 
sage 
TffST<id> 
node 
that 
ACCEPT<id> 
cates  whether 
(Note 
returned 
mean 
for  attaching 
phase).  During 
FINDMOE-ACK<id,w, 
minimum 
weight 
descendants 
enters 
the 
FINDMOE-ACK 
the  weight 
the 
CHANGE-ROOT<id> 
moe. 
then  proceeds 
protocol 
protocol, 
ie.,  when 
CHANGE-ROOT<id> 
to  over 
and  starts 
find  a  new  moe.  Note 
each 
choose 

of 
fragment. 

the  outgoing 

If  no  other 

finding 

At 

of 

of  u.  After 
found 

edge 
a  process  over 

it  sends  a  CONNECT 
two 

to  merge 
the 
if 

the 
“extended” 
there  are  m 

that 

then  at  least 
edge. 

its  own  moe, 

two  of  them  will 

the  same  outgoing 
that  other 
is  being  performed. 

topologicaI 

fails  and  u’ 

Such  a  failure 

divides 

As  explained 
fragments. 

message 
identity 
the  root 

failure 

process 

fragment. 

fragments. 

link  e’=(u’,v’) 

id’ 
is  the  new 
failure.  When 

Suppose 
this  process 
that 
the 
two  more 
the  root  of  one  of  the 
a  FAILURE<id’> 
where 
recent 
will 
last 
and 
failure 
doned 
failure 
messages 
fragment. 

a  new 
by  giving 

start 
failure 
finding 

contain 

that 

a  new 
a  new  outgoing 

process 
because 
has  now  been  divided. 

initiated 
by 
the  original 

the 

For 
instance, 
is  the  parent 

changes  occur  while 
assume 
in 
of  v’ 
into 
before  v’  will  become 
u’  will  send 
However, 

fragment 

the 

root  of  its  fragment, 

to  the 
corresponding 
receives  such  a  message 

to  the  most 
it 
the 

to 

to 

corresponding 
its  current 
edge.  Observe 
the 
failure  of  e  will  be  aban- 
that 
any 

fragment 
that 

A  node  will 

by 
ignore 

created 

fragment 

id 

the 

identity 

given 

to  the  original 

Fig. 

3 

fragments  merge  and  nodes  u  and  v  belong 

Conversely, 
recovered 
for 

fragment 

if 
links 

to 

the 
the  outgoing 
links  of  a 
then  only  one  of  them 
in 

as  described 

expansion, 

fragment. 

the 
same 
fragment 
will  be  selected 
detail 

are  all 

in  the  next  section. 

MST 

Protocol. 

4.  Description 

of 

the  Resilient 
In  this  section,  we  describe 
involved 
(A 

in  updating 

formal 

description 
initial  MST 

and 

the  MST, 

the  actions 

is  given 
is  a  directed 

taken  by  a 
the  messages 
It 
is 
tree. 
in  sleep  state.  First,  we  shall 
and 
and 

failure 
failures 

[3]). 
rooted 

courses  of 

in 

interaction 
is  described 

when 
later. 

the 

that 
all  nodes  are 
separately 
processes.  The 
in  time 
overlap 

the  normal 

node 
used. 
assumed 
Initially, 
describe 
recovery 
recoveries 

failure 

of  any 
recovered 

its  adja- 
it 
links, 

where 

node  u  is 
fails,  node  u  (in  sleep 

generated 

to  its  parent, 
by 
failure 

the 

4.1. 

Failure 
When 

Response. 

a  node  detects 

the 

cent  non-tree 
deletes 
simply 
Consider 

links 
it  from 
any 

or  unprocessed 

its  local  memory. 

tree 

link  e=(u,v), 

link 

id(e) 

If  this 

identity 

is  the  new 

the  parent  of  node  v. 
state)  sends  a  message  FAILURE<id(e)> 
where 
of  e  (as  explained 
propagated 
ing 
its 
marks 
and  also  enters 

this  message  enters 
identity 

to  be 
itself  as  the 
the 
Upon  entering 

id(e).  Node 
root 
(of  the 
reiden  state. 
the 

upwards 

reiden 
in  which 

phase 

broadcast-echo 
sage  REIDEN<id> 
nodes 
message, 
identity 

to  the 

in  the 

changes 

which 

travels 

fragment. 

Every 

node 
reiden 

to  the  root. 

in  section  3.2.1).  This  message  will  be 
receiv- 
into  a  reiden  state,  and  changes 
hand, 
v), 

v,  on 
fragment 

root  upon 

the  other 

containing 

The 

the 

root  enters  a 
state, 
the  mes- 
it  broadcasts 
the 
to  all 
receives  such  a 

down 
that 

tree 

its  state 

to 

and 

its 

fragment 

identity 

contained 

in  the  message.  Each 

334 

If  the  root  of  a  fragment 
going  edge  (i.e.,  either 
the 
network  or  it  is  disconnected 
work), 
the  and  enters  into 
such  a message will  also  into  the  sleep  state. 

finds  that 
there  is  no  out- 
fragment  spans  the  entire 
the  rest  of  the  net- 
it  broadcasts  a  GOSLEEP  message  over 
the  sleep  state.  A  node  that  receives 

from 

then 

of 

in  [3]). 

failures, 

4.1:  Corresponding 
there  is  no  recovery), 

the  protocol 
the  following  proposi- 

the  above  description 
for  link 

Based  on 
implementation 
tion  is  presented  (the  proof  can  be  found 
to  a  set  of  failures 
Prooosition 
(suppose  that 
if  the  final  graph 
is 
still  a  connected  graph,  then  the  tree  maintained  by  the 
protocol 
is  the  MST  of  the  final  graph  and  each  node 
returns 
if  the  final  graph 
to  the  sleep  state;  otherwise, 
in  each  connected  com- 
becomes  disconnected, 
ponent, 
the  MST  of  this  sub- 
graph  and  each  node  in  each  connected  component  will 
enter  the  sleep  state. 

the  protocol  maintains 

then, 

4.2.  Recovery 

Response. 

to 

to 

sends 

is  the 

Initially 

recover 

parents, 

and 
its 

that  detect 

the  message  is  simply 

link  e=(u,v). 
(with 

the 
messages  where 

at  each  node,  change  their  states 

Consider  a  recovered 
all 
nodes  are  in  a  normalstate 
respect  to  recoveries). 
The  end  nodes 
recovery,  exchange 
fragment 
id 
ID-CHECK<id> 
identity 
to  recover, 
and  send  a  RECOVERY<id,w(e),w(p)>, 
where  w(p)  is 
the  weight  of  the  link  going  to  the  parent.  A  node  that 
checks  if  the  frag- 
receives  a  RECOVERY<id,w(e),w> 
id  is  not  the  same 
ment  id  is  the  same.  If  the  fragment 
then  a  failure  has  happened  and  the  fragment 
is  being 
reidentified.  Thus 
ignored.  Con- 
versely, 
if  the  id  is  the  same  then  the  node  changes  its 
state 
wherz 
RECOVERY<id,w(e),w’> 
where  w(p)  is  again  the  weight  of  the 
w’=max{w,w(p)} 
to  the  parent  of  the  node.  This  process  is 
link  going 
least  com- 
continued  until 
lca(u,v).  This 
mon  ancestor 
message  from  u  and 
node  will 
first. 
from  v.  Suppose  that 
Then 
the  RECOVERY 
the 
parent  of  the  lea  node  as  explained  above.  Conversely, 
the  message  from  u  will  not  be  forwarded. 
it 
will  be  stopped  at  the  lea  or  further  action.  When 
the 
root  receives  the  RECOVERY<id,w,w’> 
message from 
a  child 
mes- 
sage  which 
the  serial- 
ization  of  the  recoveries  (see Section  3.2.2).  If  this  mes- 
sage  reaches  the  lca(u,v)  after  the  second  RECOVERY 
from  v  then 
because  no  serialization 
second  RECOVERY 
then 

to  the  root 
if  the 
message  has  not  been  received 
the 

it  responds  with  a  PRIVILEGE<id,w,O> 
functions  as a  token  that  permits 

the  message  arrives  at  the 

message  is  forwarded  over 

the  message  from  v  arrives 

of  u  and  v,  denoted  by 

is  necessary.  Conversely, 

message  is  forwarded 

receive  a  RECOVERY 

this  PRIVILEGE 

the  PRIVILEGE 

is  returned 

Instead 

to 

If 

lca(u,v) 

over  the  appropriate  path. 
the 

the  node  will 

reaches  a  node 

that  has 
message  (i.e.  because  another 
release  the 
lca(u,v). 
the 
to  the  root. 
the  root  will  send  a  new 

reach 
will 
is  returned 

this  point 

is  another 

the  PRIVILEGE 

the  RECOVERY 
is  taking  place)  then 

cycle. 
stopped 
recovery 
message  and  the  RECOVERY 
the  PRIVILEGE 
At 
If  there 
recovery, 
PRIVILEGE 
finally 
When 
messages  it  starts 
RECOVERY 
replace  the  edge  in  the  cycle  with 
To  do  this, 
cycle. 
the  link  with 
link  as a  non-tree 
forwards 
hand,  a  node  that 
maximum  weight  will  change 
forward 
the  original  REPLACE 
receives  a  REPLACE<id,w(e),oo> 
parent-child 

a  REPLACE<id,w(e),oo>. 
is  not  adjacent 

If  the  node  receiving 

the  message  is  adjacent 
it  marks 

two 
the  process  that  will 
the  maximum  weight. 
over  the 
to 
the 
link,  changes  its  state  to  normal,  and 
the  other 
the 
to  normal  and 
message.  A  node  that 
the 

to  the  link  with 

it  sends  a  REPLACE<id,w(e),w> 

the  maximum  weight 

its  state 

receives 

relation. 

reverse 

then 

the 

On 

will 

It  should  be  clear 

that 

in 

the 

implementation 

described  above,  the  recovery  processes  proceed  sequen- 
tially  as suggested  in  Section  3.2.2. 

of 

the 

link 

recoveries, 

is  presented  (the  proof  can  be found 

4.2:  Corresponding 
there  are  no  failures), 

the  above  description 
for 

the  protocol 
Based  on 
following 
the 
implementation 
in  [3]). 
proposition 
to  a  set  of  recoveries 
ProDosition 
if  the  final  graph  is 
(suppose  that 
then  the  tree  maintained  by  the 
still  a  connected  graph, 
is  the  MST  of  the  final  graph  and  each  node 
protocol 
to  sleep  state;  otherwise, 
returns 
final  graph 
in  each  connected  com- 
becomes  disconnected, 
ponent, 
this 
subgraph  and  each  node  in  each  connected  component 
also  enters  sleep  state. 

the  protocol  still  maintains 

the  MST  of 

then, 

the 

if 

of  Failures 

and  Recoveries. 

4.3. 

Interaction 
Suppose 

that  a  node  u  is  the  Cca of  an  ongoing 
assume  that  u  is  also 
in  a  failure  process.  Then  u  will  hold  the 
the  failure  process  is  finished. 
that  a  failure  process  may  cause 
this  only  hap- 

recovery  process.  Furthermore, 
participating 
REPLACE 
Note  that 
a  delay  in  the  recovery  process.  However, 
pens  in  some 

message  until 
this 

instances. 

implies 

Suppose  now  that  one  of  the  link 
recovery  process  fails.  Then 

ongoing 
fragment  will 
generated  by 
they  will  contain 
recovered 
they 
nodes  can  “remember” 

in  the  cycle  of  an 
the  nodes  in 
the 
and  the  messages 
recovery  will  be  discarded  because 
the  old  identity.  The  end  nodes  of  the 
link  will  start  a  new  recovery  process  (after 
the  end 
link 

identities).  Note 
the  recovery  because  the 

receive  a  new  identity 
the 

their  new 

receive 

that 

335 

defined  on  G&  , which 
of 

the  correctness 

includes 
the  protocol 

Now, 

(u,v).  0 

can  be  esta- 

link 

fragment 

(u,v)  was  a  recovered 

link  at 
and 
formed  by  adding 
than 
before 

time 
is  a  tree 
there 
into 
this 
(u,v) 
the  weight 
the 
there  are  only 

link  before 
t.  Then,  either 
link 
frag- 
of  (u,v>, 
of 
links 
node  u,  to  other 

installation 
recovered 

is  greater 

including 

first  case,  due 

there  are  simultaneous 
the  weight 
(u,v) 
induced 

is  with 

link 

of 

to  Proposition 
recovery 
less  than 
subgraph 
by  y,  assuming 

fragment 
of  y.  Thus,  based  on  Proposition 

the 
rooted 

the  MST  of  G&  which 

case, 
a  tree 
the  of 

(u,v)  will 
link  at 
the 

includes 
be 
time 
induced 

(u,v)  at 
the  only 
t.  Thus, 
subgraph 
node  u.  There- 
the  com- 

of 

to  the 
case, 

fragment 
(u,v) 

including 

is  in 

the  MST 

has  been  deleted 

link;  or 

the  component, 
of  G&. 
In  the 

that 

Suppose 
t  and  becomes  a  tree 
is  inside 
in  the  cycle 

some 

(x,y) 

time 
(u,v) 
(x,y), 
ment,  whose  weight 
and 
(u,v)  as  a  tree 
connecting 
components 
4.2  which 
and 
failure 
any  outgoing 
corresponding 
that 
3.1  (u,v) 
time 
t. 
recovered 
(u,v) 
is 
corresponding 
fore, 
ponent, 

in  either 

x 

is  the  parent 

holds  when 
processes, 

non-tree 
to 
the 

the 

is  in 
In 
second 
link  becoming 
the  moe  of 

Since 

of  the 

the  notification 

link  will  arrive  at  the 

the  connection 
where 

failure 
the  moe  which 

fragment 
disconnected. 
the  case  that 

blished. 
Theorem 
each  component 
Proof: 
any 
there  exists 
the 
finds 
process  and 
t,  or 
the 
becomes 
Also, 
in 
the  outgoing 
only  one  of  them, 
two 
finite 
time  after 
be  one  spanning 
graph. 
recovered 
implies 
tree 
no  deadlocks 
a  time 
to  be  the  maximum 
fact, 
> 
holds 
spanning 
is  an  MST  of  that  component 

recovered 
link 
(as  described 
t,  s.t.  G&  =  GL 

link  or  a  non-tree 

say 
including 

throughout 

ts.  This 

Therefore, 

link  will 

fragments 

each 

that 

5.1:  The  algorithm 

constructs 

an  MST 

for 

final  graph. 

of  topological 

two  end  nodes 

in  finite 

change  on 
time, 
t  r.  Besides, 
t  only 
it 
failure 
time 

if 

done  at 

t  r  s.t.  GL  =  G,! 
process  will 

terminate 

for  all 
at 

t  > 
time 

is  not  selected  by  any  other 

is  successfully 

this 

failure 
with 
ail  other 
there  are  only 

edges  of  some 

fragment, 

process  originated 
fragments 
recovered 
then 
to  merge 

(u,v),  will  be  used 

u  and  v  respectively. 
topological 
change 

last 

the 
tree  on  every 
that 
inside 

from 
be 

component 

time 
some 

of 
onward, 
fragment. 

link  will  either 

time  since 

in  finite 
in  Section  4.  Hence, 
for 
of  t  r  and 

time 
t 2.  If  we 
t2,  then  GE  =  Gb 

t  > 

combined 
the  computation, 

with  Property 

will 

imply 

the 

Thus, 

in  G&. 
links  as 
one  and 
the 
in 
there  will 
final 
every 
This 
become 
a 
there  are 
is 
t, 
t 

there 
let 

for 
5.1  which 
the 
t, 

t  > 

that 

tree  T  on  each  component 
of  the 

for 

of  G& 
final  graph.  q 

remains 

unclassified. 

We  have 

described 

how  a 

recovery 
affect  a  failure 

process. 

However, 

a  link 

process  as  follows. 

failure  may 

a 
recovery  may  also 

affect 

hold  any  message 
topology 

the 

These  messages  will 

its 

for 

return.  At 

Ica  node  has  sent  a  REPLACE 
the 
time 
over 
the 
is  being 
the 
that 
it 

this 
travel 
cycle 
sent  when 
a  node 

that  will 
the 
be 

Similarly, 

of 

is  returned. 

lea  will  hold  any  FAILURE  message  when 

in  a  recovery 
is  being  changed 

process  because 

the 

topology 

and 

the  parent-child 

rela- 

because 

that 
an 
is  waiting 

Assume 
message  and 
node  will 
cycle 
adjusted. 
REPLACE  message 
is  not  an 
is  involved 
of  the  cycle 
tions  are  being  changed. 
It  can  be  observed 
failures 
l 

still  hold  when 
ously 
(see  [3]). 

that  Propositions 

4.1  and  4.2 

and 

recoveries 

occur  simultane- 

5.  Proof  of  Correctness. 

we  briefly 

outline 

the  correctness 

In 

the 

(x,y) 

at  all 

following, 
proof  of  the  protocol. 
Let  Gj  denote 
the 

to  be  the 

and  E(G&) 

times). 
network, 
network  without 

the  nodes  and 
Define  Gi 
information 
the 
words,  a  link 
have 
recorded 
the  delays 
identical 
computational 
logical 
=  V(Gi) 
in  R  t 
it  as  a  recovered 
ProDertv 
if  a  link 
(u,v) 
is 
includes 
Proof: 
before 
due 
mixture 
described 
specific 
on 
the 
MST  of  the  component, 
(u,v). 

(u,v) 
in 
(u,v). 
Suppose 

to  Proposition 
failure 

edge. 
5.1:  At  any 

the  MST 

time 

that 

of 

stored  at  each  node  at  time 

is  in  CL 

links 

that  are  operational 

the  physical 

logical 

time 

network 

network 

corresponding 

at  time 
at 

t  i.e., 
t. 
to 
t.  In  other 
if  both  node  x  and  node  y 
to 
Gj  and  GL  may  not  be 
to  define  a 
the 

as  GE,  which 

(Note 

that, 

due 

is 

links 

i.e.,  V(G&) 
-  R  t,  where  an  edge 

is 

It 

is  also  convenient 
denoted 
the 

recovered 

=  E(Gi) 

(x,y)  as  operational. 

in  the  notifications, 

if  either  or  both  of  its  end  nodes  have 

recorded 

time 

t  during 

the  computation, 

is  classified 
of 

as  a  tree 
the  component 

link  by  node  u,  then 
of  GE  which 

t  and  becomes  a  tree 

link 
t.  Then, 
there 

link 

(u,v)  was  a  non-tree 

link  at 

recovery 

time 
4.1  which  holds  even  when 
processes  and 

is 
processes  as 
(u,v)  must  be  an  moe  of  some 
based 
the 
in 
includes 

Therefore, 
is 

defined  on  G&,  which 

(u,v) 

in  section  4.3, 

set  of  nodes  defined  on  G&. 
fragment 
property, 

expansion 

1  Also 
between 

see 

(3) 

for  a 

further 

discussion 

on 

the 

interactions 

failure  and  recovery  processes. 

336 

6.  Complexity 

Analysis. 

References 

that 

the  FAILURE 

Suppose  that 

the  new  identity 

message  travels  over 

the  network  has  n  nodes  and  e edges. 
Moreover,  assume  that  a single  failure  occurs.  It  can  be 
noted 
the 
broad- 
edges  of  a  tree  with  O(n)  messages.  Similarly, 
casting 
the 
require  O(n)  mes- 
new  moe,  and  merging 
sages  since  these  activities 
the  edges  of 
are  done  over 
the  tree.  However, 
the  minimum  outgoing  edge 
to  find 
fragments,  messages  need  to  be  sent  over  O(e) 
of  the 
non-tree 
for  a  sin- 
gle  failure 

the  message  complexity 

is  O(e)  messages. 

the  fragments 

links.  Thus 

fragment, 

of  the 

finding 

Suppose  now  that  a  single  recovery  occurs.  As  in 
links  of 
links  are  traversed.  Therefore, 
is  O(n)  messages. 

the  above  case,  the  messages  travel  only  over 
the  tree  and  no  non-tree 
the  complexity 

for  a single  recovery 

failures 

As  mentioned 

in  previous  Sections,  some  of 

to  find  its  moe  is  lost.  Therefore, 

the 
of  a  failure  or  a  recovery  may  be  lost  because 
activity 
(see  Sections  4.1  and  4.3). 
of  subsequent 
Nevertheless,  when  a  link 
failure  occurs  within  a  frag- 
ment  F,  it  suspends  any  failure  process  in  progress  in  F 
as  well  as  the  concurrent 
recovery  processes  in  F  (if 
any)  and  a  completely  new  process  is  started.  Note  that 
failure  processes,  the  effort 
for  each  of  the  suspended 
the  messages 
devoted 
lost  are  bounded  by  2ef6n.  Similarly, 
suppose  that  all 
suspended 
in  dis- 
joint  cycles  of  the  fragment.  Then 
the  messages in  each 
traverse  on  the  links  of  the  relevant  cycle. 
process  only 
Thus, 
the  total  number  of  wasted  messages  is  at  most 
the  protocol  uses  only  O(me+kn)  mes- 
3n.  Therefore, 
for  the  final  graph  where 
sages  to  reconstruct  an  MST 
m  and  k  are 
failures  and 
recoveries  respectively.  Note 
that  e  and  n  refer  to  the 
maximum  number  of  edges  and  nodes  in  the  graph  dur- 
ing  the  computation. 

recovery  processes  are  taking  place 

the  numbers  of 

tree 

link 

the  cycles 

The  best  case  message  complexity 

O(n)  when 
disjoint.  The  best  case  message  complexity 
is  O(e)  when  all 
different 

is 
these  recoveries  are 
for  failures 
the  fragments  except  one  choose  the 

for  recoveries 

formed  by 

links  as their  respective  moe. 
case  time  complexity 

that 

(evaluated 

The  worst 

it  takes  one  time  unit 

link) 
the  computation. 

assuming 
across  any 
used  during 
plexity 
height  among  the  fragments  created  during 
tation. 

to  O(H)  where  H 

by 
to  send  a  message 
to  number  of  messages 
The  best  case  time  com- 
the  maximum 
the  compu- 

is  also  equal 

is  equal 

is 

Weight 

Spanning 

Evanston, 

University, 

a  Minimum 

to  Maintain 

in  Multihop 

and  S.  Even, 

in  a  Dynamic 

and  S.  Kutten, 

Radio  Networks,” 

“A  Resilient  Distri- 

“An  Almost  Linear  Time 

“A  Protocol 
Tree 

“Optimal  Distributed  Algorithm 

Topology,”  M.S. 
IL, 

for 
Tree,  Counting, 
Symp. 

“Reliable  Broadcast 
in  Unreliable  Networks,”  Networks,  vol. 

Algorithm 
Spanning  Trees,”  26th  Symp. 
of  Comp.  Sci.,  pp.  257-266,  Port: 

“Tree-Based  Broad- 
IEEE 
on  Comp.,  vol.  C-36,  no.  10,  pp.  1209-1223, 

B.  Awerbuch 
Protocols 
16,  no.  4,  pp.  381-396,  Dec.  1986. 
B.  Awerbuch, 
Minimum 
Leader  Election, 
and  Related  Problems,” 
Theory  of  Comp.,  pp.  230-240,  May  1987. 
C.  Cheng, 
Spanning 
Thesis,  Northwestern 
June  1988. 
F.  Chin  and  H.F.  Ting, 
and  O(nlogn+e)  Messages  Distributed 
for  Minimum-Weight 
on  Foundations 
land,  OR,  Oct.  1985. 
I.  Chlamtac 
casting 
Trans. 
Oct.  1987. 
LA.  Cimet  and  S.P.R.  Kumar, 
for  Network 
buted  Protocol 
ACM  SIGCOMM 
and  Pro- 
Symp.  Commun.  Arch. 
tocols,  pp.  358-367,  Stowe,  VT,  Aug.  1986.  Also  in 
Computer  Communications  Review, 
vol.  16,  no.  3. 
“A  ResiIient  Distri- 
LA.  Cimet  and  S.P.R.  Kumar, 
buted  Algorithm 
Spanning 
Proc.,  pp.  196-203, 
Trees,” 
St.  Charles, 
Y.K.  Dalal  and  R.M.  Metcalfe, 
“Reverse  Path  For- 
warding  of  Broadcast  Packets,”  Commun.  ACM, 
vol.  21,  no.  12,  pp.  1040-1048,  Dec.  1978. 
N.  Francez, 
Termination,” 
TOPLAS, 
E.  Gafni, 
of  Two  Message-Optimal  Election  Algorithms,” 
ACM 
175-185,  Minaki,  Ont,  Canada,  Aug.  1985. 
R.G.  Gallager,  P.A.  Humblet,  and  P.M.  Spira,  “A 
Distributed  Algorithm 
for  Minimum  Weight  Span- 
ning  Trees,”  ACM 
Lang.  Syst., 
vol.  5,  pp.  66-77,  Jan.  1983. 
R.  Perlman, 
111-111,  asfasfsaf,  date. 
A.  Segall,  “Distributed 
Trans. 
Jan.  1983. 

vol.  2,  no.  1,  pp.  42-55,  1980. 
“Improvements 

IEEE 
IT-29,  no.  1,  pp.  23-35, 

4th 
of  Dist.  Comp.,  pp. 

in  the  Time  Complexity 

Int’l  Con/.  on  Parallel 

Network  Protocols,” 

for  Minimum-Weight 

Synchronization,” 

IL,  Aug.  1987. 

Trans.  Program. 

on  Principles 

“Distributed 

Inf.  Theory, 

‘&Gateway 

routing,” 

safasasf, 

Symp. 

ACM 

pp. 

vol. 

1. 

2. 

3. 

4. 

5. 

6. 

7. 

8. 

9. 

10. 

11. 

12. 

13. 

337 

APPENDIX: 
Algorithm 

Formal 

Description 

of 

the 

Resilient 

This  appendix  presents  a  brief  formal  description  of  the 
is 
the  messages  and 
that  some 

:haL  the  reader 
used  in  the  GHS  algorithm.  Also  note 

(for  a  complete  description 

is  familiar  with 

resilient  protocol 
assumed 
variables 
trivial  parts  are  omitted. 

see  [31). 

It 

for  link  (u,v). 

end  when 

if  f-state=reiden 

or  f-state=jindmoe 

send  FAZLURE<fid> 
if 

to  parent. 

then 

if 

end 
if 

end 

over  (u,v). 

else 

(1)  Response  of  node  u  to  failure  notification 
if  (u,v) 

is  a  tree  link 

then 
generate  new  fragment 
if  u  is  a  child  of  v  then 

identity 

lid. 

u  becomes  the  root  of  fragment. 
f-state+reiden. 
idtfid. 
send  REIDEN<id> 

to  all  children. 

if  f-state=jound 

then 

hold  FAILURE  message. 

else 

else 

end 
if 

end 
if 

end 

(2)  Response  of  u  to  FAZLCJRE<fid> 
if  u  is  root 
idtfid; 
send  REZDEN<id> 

then 

to  all  children. 

else 

end 

send  FAZLURE<fid> 
if 

to  parent. 

(3)  Response  of  u  to  REZDEN<fid> 
idcfid. 
f-state+-reiden. 
if  u  has  no  children 

then 

send  REZDEN-ACI(<id> 

to  parent. 

else 

end 

send  REZDEN<id> 
if 

to  all  children. 

(5)  Response  of  u  to  FZNDMOE<fid> 
if  id=fid 

then 

over  (u,v). 

use  TEST<id> 
if  u  has  no  children 

then 

to  find  all  incident  outgoing  edges. 

send  FZNDMOE-ACK<id,moe> 
(moe  is  the  local  moe  of  u) 

to  parent. 

send  FZNDMOE<id> 
if 

to  all  children. 

(6)  Response  of  u  to  FZNDMOE-ACK<fid,e> 
if  id=fid 

then 

over  (u,v). 

if  u  is  leader  then 

send  CHANGE-ROOT 

to  child  who  reported  moe. 

else 

end 

else 

if  u  received  FZNDMOE-ACK 

from 

every  child 

then 

send  FZNDMOE-ACK<id,moe> 

with 

local  moe. 

to  parent 

over  (u,v). 

(7)  Response  of  u  to  CHANGE-ROOT<fid,e> 
let  a  child  of  u  be  the  parent. 
if  e is  an  incident 

link 

send  CONNECT 

then 
over  moe. 

send  CHANGE-ROOT 

in  FINDMOE-A 

CK. 

to  child 

that 

reported  e 

end 

if 

(8)  Response  of  u  to  recovery  notification 
if  u  and  v  are  in  the  same  fragment 

then 

for  (u,v). 

(9)  Response  of  u  to  RECOVERY<fid,w,w’> 
if  u  received  a  RECOVERY  message  from  node  x 

over  (u,v). 

for  the  same  recovery 

then 

wait 

until  u  has  received  echo  then 

send  REPLACE 

to  child  reporting  maximum  weight 

over  (u,v). 

end 

send  RECOVERY 
if 

to  parent. 

(4)  Response  of  u  to  REZDEN-ACK<fid> 
if 

id=fid 

then 

if  u  received  REZDEN-AQZ<<fid> 

over  (u,v). 

from  every  child 

the1 

end 

end  wait 
if 

if  u  is  leader  then 

send  FZNDMOE<id> 
f-state+-find. 

to  all  children. 

else 

end 
if 

end 
if 

end 

send  REZDEN-ACZ(< 
if 

id > 

to  parent. 

338 

A  Protocol 

to  Maintain 

a  Minimum 

Spanning 

Tree 

in  a  Dynamic 

Topology 

* 

C.  Cheng, 

I.A.  Cimett, 

and  Srikanta  P.R.  Kumar 

Electrical 

Engineering 

and  Computer 

Science  Department 

Northwestern 
Evanston, 

University 
IL  60208 

Abstract 

We  present  a  distributed 
a  minimum-weight 
with 

changing 

protocol 

for  updating 

spanning 

tree 

(MST) 

topology. 

The  protocol 

and 
in 
can 

to  multiple 

link/node 

failures 

can  occur  at  arbitrary 
finite  number 

of  topological 

times.  Given 

the  protocol 

network, 

The  message 
h w  en 
occur,  where 

links, 

within 

finds 

the  MST 
finite 
complexity 

link 
k 
IV1  and 
respectively. 

recoveries 
[El  are 

and 

recoveries 
that  an  arbi- 
changes  occur  during 
to 
last 
is 
link 
number 

corresponding 
the 
protocol 
and  m 
total 

time 
of 

after 

the 

the 

maintaining 
a  network 
respond 
that 
trary 
a  period, 
the 
change. 
O(+l+klW 
failures 
of  nodes  and 

latest 

1. 

Introduction. 

A 

spanning 

tree 

a  minimally 

represents 
all 
the  nodes 
in  point-t-point 
casting 
ascertain 
termination) 
local-area 
multihop 

[8], 

in 

the  network. 
networks 

in  selecting 

certain 

conditions 
[9].  Spanning 

Such 

of  a  communication 
connected 
structure 

network 
containing 
trees  are  employed 
for  efficient  message  broad- 
to 
or 
in 
in 

trees  have  also  been  used 
[12]  and 

(e.g.:  mutual 

processor 

a  ‘leader’ 

exclusion 

routing 

[lo], 

or 

networks 

for  gateway 

radio  networks 

for  bandwidth 

a  cost  or  weight 
fees  or  delay) 

is  associated 

with 

allocation 
(representing, 

[5]. 

In  general, 
usage 
the 

network. 

example, 
links 
of 
whose  edges  have  minimum 
the 
Minimum-Weight 

tasks  mentioned 

Spanning 

Therefore, 
weight 
This 

above. 

the 
is  usually 
tree 

spanning 

needed 

is  called 
(MST).  One  of 

Tree 

for 
the 
tree 
in 
the 
the 

*  This  work  was  supported 

in  part  by  grants  from  US-WEST 

Advanced  Technologies, 

and  from  Bell  Northern  Research. 

fee all  or  part  of  this  material  is granted  provided 
for  direct  commercial  advantage, 

Permission  io  copy  without 
that  the  copies  are  not  made  or  distributed 
the  ACM  copyright  notice  and  the  title  of  the  publication  and  its  date  appear, 
and  notice  is given  that  copying  is by  permission  of  the  Association 
Computing  Machinery.  To  copy  otherwise,  or  to  republish,  requires  a fee and/ 
or  specific  permission. 

for 

for 

point-to-point 

as  the  GHS  protocol) 
[ll]. 

and  Spira 

in 

the  GHS  protocol 

II&works 
was  presented 
In  a  network 
transmits 

MST 

denoted 

Humblet, 

protocols 

first 
(hereafter 
by  Gallager, 
of  n  nodes  and  e  edges, 
O(nlogn+e) 
uses  O(nlogn) 
protocol 

messages,  with  O(logn) 

bits/message, 

time  units. 
has  been  recently 
the  most  part,  protocols 

(The 
improved 

For 

time  complexity 
(2,  4,  lo]). 

run  over  a  communi- 

and 
of  this 

changing 

topology. 

additions 
the  course  of 

and  deletions 

time. 

Hence,  many 

past 

in  spite  of  topological 
the 
called 
protocol 

resilient 

decade 

the  MST 

for 

or 

The  changes 

in 
of  nodes  and 

protocols 
changes  have 
[1,  6,  131). 
In  par- 
was 

problem 

(e.g.: 
reliable. 

entail 

to  run 

cation  network  with 
topology 
links  over 
that  are  able 
been 
designed 
These  protocols 
ticular, 
proposed 
In 

a  resilient 
in  171. 

in 
are 

this  paper,  we  present 

a  new 

in 

time 

it  will  be  shown 

(i.e.:  a 
is  being 

to  topological 
recoveries, 

of  topological 
a  period 

buted  MST  protocol.  Given 
col  responds 
lfailures 
and 
failures/recoveries 
overlap 
while 
another 
finite  number 
times  during 
period), 
the  MST 
finite 
link 
0(  kn+me) 
trast, 
struct 
sage 
O(logn) 
more 
MST 
with  O(e)  bits/message. 

if  one  uses  a  protocol 
the 
complexity 

corresponding 
the 
and  k 
messages, 

tree  after  every 

efficient 
protocol 

time 
failures 

bits/message. 

last 
link 

after 

will 

to 

an  initial  MST, 

changes  caused  by 

resilient 

distri- 
the  proto- 
link/node 
the  MST.  Multiple 

and  updates 

simultaneously 
can  occur 
failure 
recovery 
or 
processed). 

Assuming 

or 

can 
can  occur 
a 

that 

changes  occur  at  arbitrary 

(and  no  more  changes  after 

this 
the  protocol  will  obtain 
latest  network 

that 
the 

topological 
recoveries, 

each  with  O(logn) 

failure 

(such  as  GHS) 
or  recovery, 
be  O((m+k)*(nlogn+e)), 
presented 
than 

the 

uses  O((m+k)*n) 

The  protocol 
for  dense  networks 
in 

[7]  which 

within 

a 
change.  Given  m 
the  protocol 
uses 
In  con- 
to 
recon- 
the  mes- 
with 

bits. 

is 

herein 
resilient 
messages 

The  paper 

is  organized 

as  follows. 

The  distributed 

computation 
Section 
theoretic 
buted 

and 

2.  Section 
properties 

communication 
3  ‘expiains 
and 

model 

the 

underlying 

are  given 

in 
graph 
of  the  distri- 
the 
resilient 

the  main 
Section 

features 
4  describes 

implementation. 

o 

1988  ACM  O-89791-279-9/88/008/0330 

$1 SO 

t  LA.  Cimet  was  with 

the  EECS  Dept.,  Northwestern 

ty.  He  is  now  with  AT&T  Bell  Laboratories, 

Naperville, 

Universi- 
IL,  60566. 

330 

MST  protocol.  Section  5  presents  a  sketch  of  I IIC proof 
of  correctness.  Finally,  Section  6  contains 
the  complex- 
ity  analysis. 

2.  Computational 

Model. 

is 

identity 

number, 

involving 

where  V 

for  the  protocol 

The  environment 

is  a  computing  unit 

queue  with  unlimited 

(u,v),  assigned  with  a  weight  w(u,v), 

is  an  asynchrc+ 
represented  by  an  undirected  weighted 
the  set  of  nodes  and 
is  the  set  of  links.  Each  node,  assigned  with  a 

nous  network 
graph  W,E), 
ECVXV 
unique 
a  processor,  a  local  memory,  and  also  an  input  queue 
capacity.  Each 
and  an  output 
link 
is  a  bidirec- 
line  connecting  nodes  u  and  v. 
tional  communication 
(the  iden- 
Each  node  knows  only 
its  local  environment 
tity  and  the  weights  of  its  links)  and  follows 
the  same 
protocol  which  consists  of  sending  and  receiving  mes- 
sages  over 
these 
messages.  The  received 
in  the 
input 
basis,  and 
are  also  processed  in  that  order. 

links,  and  processing 
(sent)  messages  are  put 

queue  on  a  first-in-first-out 

the  adjoining 

(output) 

link 

and 

the  link 

transmitted 

is  functioning, 

A  communication 

transmission.  When 
independently 
they  arrive  at 

in  a  dynamic  network  has 
the  following  properties.  Messages  can  only  be  sent  and 
received  over  a  link  which 
is  functioning.  However,  a 
message  need  not  arrive  at  the  receiver,  as the  link  may 
fail  during 
in  both 
messages  can  be 
the  other  end  after  a 
directions, 
in 
finite 
fails  or  recovers,  both  ends 
sequence.  Whenever  a  link 
finite 
the 
are  notilied 
in 
the  time  when  a  link  recovers,  there  are 
same  time.  At 
it,  nor  are  there  mes- 
no  messages  in 
sages  waiting 
to  be  sent  over  it  (i.e.,  all  messages  sent 
out  for  transmission  on  a  link  are  deleted  after  the  link 
fails).  Observe  that 
these  properties  are  commonly  used 
in  the  literature 

time  but  not  necessarily  at 

delay,  without 

(see  [  1,  131). 

undetermined 

through 

transit 

error 

and 

3.  The  Resilient 

MST 

Protocol. 

a 

of 

of  all 

a  finite 

Assume 

that  a  graph  G(V,E) 
its  MST.  Furthermore, 

the 
finite 

find,  within 

links 
number 

change,  an  MST 

along  with 
weights 
Thereafter, 
recoveries  occur  at  arbitrary 
col  must 
logical 
graph. 
Definition 
cal  change  in  the  network,  where 
ti 
the  change  occurs  and  ei  is  the  link 
ers  at 
recovery,  and  Ei,,=Ei-{ 
E,=E. 

Let  Ei+,= 
ei } 

3.1:  Let  Ci =<ei 

define  Vi 

Similarly, 

time. 

that 

is  given 
suppose 

initially 
that 

are  distinct 

(see 
failures 

the 
[ll)). 
and 
times.  The  resilient  proto- 
the  last  topo- 
to 
latest 

time  after 
corresponding 

link 

the 

,ti  >  be  the  i-th 

topologi- 
is  the  time  when 
fails  or  recov- 
is  a 
is  a  failure,  with 
to  be  the  set  of  nodes  in 

that 
EiU{ei} 

if  Ci 

if  C; 

the  graph  after  Ci.  Then 
the 
Si  =G(  Vi  ,Ei  ). 

topological 

i-th 

the  surviving 
change 
is 

net,ulork  after 
denoted 
by 

Suppose  that  only  k  topological 

the  network.  Then, 
an  MST 

for  Sk . 

the  distributed 

changes  occur 

in 
algorithm  must  find 

Properties. 

3.1.  Underlying 

Graph 
Before  the  distributed 

Theoretic 
implementation 

is 

in 

involved 

responding 

is  described, 
link 
we  outline  what 
theoretic  proper- 
failures  and  recoveries,  and  the  graph 
ties  underlying 
These 
properties  will  be  the  basis  for  the  collective  action  of 
the  nodes  involved 
process.  For 
notation  will  be  adopted. 
convenience, 
the 
Given  a  tree  T, 
denote 
the  deletion  and  addition  of  edge  e to  T. 

following 
let  T-e  and  T+e 

in  a  failure/recovery 

the  reconstruction 

of  the  MST. 

respectively 

to 

this 

link, 

then 

fails. 

If  e  is  a  non-tree 

First,  consider  a  single 

then  T’=T 
is  needed.  Conversely, 
two 

failure.  Let  T  be  the 
link 
to  the  failure,  and  let 
MST  of  the  graph  G(V,E)  prior 
link 
T’  be  the  MST  of  G(V,E-{e}),  where  eEE  is  the 
and  no 
that 
if  e  is  a 
updating  of  the  MST 
tree  link, 
fragments 
T  r  and  T,.  These  two  fragments  must  be  reconnected, 
if  at  all  possible, 
observed 
weight 
(see  (71).  (If 
then 
nected). 

the  new  MST. 
where  e’  is  the  minimum 
link  connecting  a  node  in  T  1  to  a  node  in  T, 
T  r  and  T,, 
is  discon- 

is  no  link  connecting 

failure  splits  T  into 

that  T’=T-e+e’, 

the  graph 

It  can  be 

to  obtain 

resulting 

failure 

there 

from 

the 

the  MST 

for  the  moment), 

(assume  no  recoveries, 

graph.  Hence,  starting 

Now,  when  there  are  many,  possibly  simultaneous, 
the  ini- 
is  broken  down  into  many  fragments.  Each  of 
is  also  a  fragment  of  the  MST  of  the 
these  frag- 
for  the  final  graph  can  be  constructed 
these  fragments,  whose 
of 
later)  will  be 

failures 
tial  MST 
these  fragments 
final  surviving 
ments, 
by  finding 
weight 
the  response 
based  on  this  idea,  and  being  so,  this  part  of  the  proto 
the  fixed-topology  MST 
co1 has  many  similarities  with 
there  are  some  impor- 
protocol  of  GHS  (111.  However, 
tant  differences,  and 
the  next 
section. 

is  minimum.  The  distributed 

the  links,  connecting 

these  are  explained 

implementation 

(described 

failures 

from 

link 

to 

in 

To  understand 

the 

consider  a  single 
the  recovered 
T’=T+e. 
then 
this 
graph, 
with 

the 
the  existing 

there 
recovery). 

then 

recovery. 
is  not 

link 

(If  both  ends  are  not 
is  no  spanning 

response 

to  a  link 

the  original  graph, 

recovery, 
If  one  of  the  end  nodes  of 
in 
then 
in  the  original  graph, 
from 
the  original 
forms  a  unique  cycle 
following 

for  the  graph  resulting 

proposition 

If  both  end  nodes  are  in 

recovered 
tree  links.  The 

link 

331 

initiates 

of  a  link 

to  update 

final  MST.  Each  of  the  end  nodes  detecting 

or  across  fragments,  and  the  appropr;;,  t.e cycle 
within 
the  fragment  and  obtain 
has  to  be  identified 
the 
the 
a  response  process, 
failure/recovery 
involve  several  other  nodes  in  the  task  to  be 
which  will 
in 
accomplished.  Such  response  processes  may  overlap 
in  more  than 
the  sense  that  a  node  may  be  involved 
one  of  them  at  the  same  time.  Before  we  present 
the 
description  of  the  protocol,  we  briefly  outline  some  of 
the  main  features  of  each  of  the  response  processes  and 
their 

interaction. 

3.2.1.  Response 

to  a  Link  Failure 

A 

[ll]. 

the 

the 

[ll]). 

(see 

arise 

failure 

failure 

identity 

fragment 

fragment 

to  which 

response 

in  nature 

the  initiated 

In  changing 

in  attempting 

issue  concerns 

first  assign  a  unique 

The  response  to  a  link 

the  failures  break  the  MST 

to 
node  belongs.  That 

fixed-topology  GHS  algorithm 
first 

topology  distributed  MST  algorithm 
initiated 

is  based  on  the  frag- 
to  the 
of  the  GHS 
by  a  node 
the 
is 
the  ingoing  and  outgoing  edges 
the  minimum  outgoing  edge 
topology 
into  several 
to 
to  this  con- 

ment  expansion  notion,  and  is  similar 
fixed 
protocol 
should 
fragment 
necessary  to  distinguish 
of  the  fragment,  and  find 
of 
environments, 
fragments.  Several  difficulties 
modify 
text.  The 
When  a  tree  link  e=(u,v) 
two 
fragments  are  formed  both  of  which  must  have  separate 
is  to  assign  the  identities 
identities.  A  natural 
(w(e),u)  and  ( w  e  v 
fragments  which  contain 
(  1,  1 
node  u  and  node  v,  respectively.  As  link  weights  and 
this  will 
node  identities 
suffice.  However, 
to 
two 
the  same  fragment 
nodes  in  separate 
these 
identity, 
at  the 
time  when 
nodes  is  tested 
and  thus,  a 
(to  see  if 
it 
to 
correct  MST  may  not  result. 
it 
situation 
see  that 
the 
assignment  of  fragment 
is  baaed  on  only  a  part 
(i.e.,  node  identities  and  link  weights  of 
of  the  fragment 
any  proper  subset  of  the  fragment). 

the  edge  connecting 
is  outgoing), 
In  fact, 

this  assignment  may 
fragments  having 

the  same  undesirable 
identity 

is  not  hard 
results 
if 

thought 
to 
the 

are  distinct, 

a  fragment, 

fails  within 

one  might 

fragment 

identity. 

think 

lead 

the 

There 

are 

two  ways 

to  avoid 
distinct 
first  approach 

situation 

the 
identities 
is  to 
let 

fragment.  With 

for 
described  above,  and  maintain 
the 
fragments.  The 
different 
identity  be  the  set  of  node  identities  of  all  the 
fragment 
that 
two 
nodes 
in 
identi- 
nodes  in  different 
ties  when 
them.  This 
testing 
approach  has  been  used  in  a  similar  problem  by  Segall 
the  message  size 
in  (131.  However,  with 
and  the  overall  bit  complexity  will 
increase,  as  a  sub- 
stantial  number  of  messages in  the  resilient  MST  proto- 
col  will  contain 

fragments  will  have  different 

the  edge  connecting 

this  assignment, 

this  approach 

the  fragment 

identity. 

e=(u,v) 

indicates  how  the  new  MST  can  be  obtained. 
Proposition 
pose 
link 
G(V,EU{e}) 
the 
that 
belong  to  V,  then  T’=T+e. 

3.1:  Let  T  be  the  MST  of  G(V,E).  Sup- 
of 
where  e’  is 
the  edges 
If  one,of  u  and  v  does  not 

is 
then  T’=T+e-e’ 

the  maximum  weight  among 

link  with 
form 

the  cycle  in  T+e. 

and  u,v~V, 

the  MST 

recovers. 

If  T’ 

recoveries, 

(as  in  Fig, 

In  order  to  extend 

l), 
3.1  must  be  first  applied 

if  the  cycles  formed  by  T+e 
If  the  cycles  overlap 

position  3.1  to  handle  many  simultaneous 
is  necessary  to  sequentially  apply 
Proposition. 
To  see this,  consider 
e 1  and  es.  The  rule  can  be  applied 
only 
joint. 
in  Proposition 
recoveries  and  then  the  remaining 
ceased on  the  resulting  graph.  The  order  in  which 
recoveries  are  processed 
Moreover, 
within 
it  forms  a  cycle  with  some  of  the  tree  links 
ment.  The  new 
above  rule 
MST). 

the  approach  suggested  by  Pro- 
it 
the  rule  given  by  this 
the  recovery  of  links 
to  both  recoveries 
I  and  T+e  z  are  dis- 
then 
the  rule 
to  one  of  the 
recovery  may  be  pro- 
these 
(see  131). 
recoveries 
recovers  within  a  fragment, 
in  the  frag- 
the 
final 

to 
(a  subtree  of  the 

important 
to 

is  also  a  fragment 

is  also  applicable 

derived  according 

fragments. 

fragment 

If  a  link 

is  not 

rule 

this 

w 

el 

Fig.  1 

e2 

The  properties  described  above  provide  a  basis  for 
features  of  which 

the  main 

the  resilient  MST  protocol, 
are  explained 

in  the  next  section. 

3.2.  Main 
mentation. 

Features 

of  The  Distributed 

Imple- 

In  a  changing  network  environment, 
and  recoveries  can  occur  simultaneously, 
can  occur  when  another  event 
any  moment, 
have  to  be  eventually 

link 
failures 
or  one  event 
is  being  processed.  At 
that  will 
combined.  Recoveries  can  happen 

there  can  be  several 

fragments 

332 

after 

) 
its 

approach 

immediately 

fails.  Then, 

An  alternative 

failure,  assign 

to  the  fragment 

to  the 
(w(e),v,k(e)) 

the 
node  u,  and 

identity.  Specially,  suppose 

is  to  have  a  counter 
times 

for 
the 
this  counter 
link 
if  k( e  is  the  counter  value  of  this 
identity 

each  link,  which  keeps  track  of  how  many 
link  has  failed  and  recovered,  and  attach 
value 
e=(u,v) 
link 
fragment 
(w(e),u,k(e)) 
the 
to 
identity 
node  v.  This  would  ensure 
identity 
fails.  Unfortunately, 
without 
the 
topological 
still  be  viable 
that  are  good  enough 
Notice 
fragment 
approach 

containing 
the 
containing 
that  a  new  and  distinct 
time  a  link 
cannot  be  bounded 
some  assumptions  on  the  time  or  the  order  of 
this  approach  may 
large  counters 
intervals. 
the 
first 

for  reasonably 
for 
the  messages  containing 
the 

identity  will  be  IV1  times 
than  with 

for  a  fragment  every 
the  counter 

changes.  However 

long  operating 

is  generated 

the  size  of 

the  second. 

in  practice 

fragment 

larger 

that 

in 

The  resilient  MST  protocol  described 

in  the  next 
section  could  be  used  with  either  one  of  the  approaches 
described  above  for  assigning  fragment 

identities. 

3.2.2. 

Response 

to  Link  Recovery. 

to 

the 

from 

have 

the  way 

recovers, 

identities. 

trees)  all 

When  a 

(note  that 

link  e=(u,v) 

the  appropriate 

is  denoted  as  the 

two  of  its  descendant 

receives  messages  corresponding 

in  the  cycle,  takes  action 
the  MST. 

then  both  end 
fragment 
If 
nodes  u  and  v  exchange 
their 
then  each  node  initiates 
both  are  in  the  same  fragment, 
a  process  to  find  the  maximum  weight  edge  in  the  cycle 
fragments 
by  propagating  a  message  upward 
to  the  root  of  the 
will  be  directed 
fragment.  The  messages  from  u  and  v  will 
‘meet’  at  a 
least  common  ancestor 
node,  which 
lca(u,v)  will  be  the 
(lea)  of  u  and  v.  In  other  words, 
node  which 
the 
(or  child) 
same  recovery, 
nodes.  This  node,  which  will 
information 
to 
about  the  maximum  weight 
If 
delete  and  insert 
fail) 
the  cycle  is  intact 
the  recovery  process,  the  goal  of  this  pro- 
throughout 
that  when  several 
ces  will  be  accomplished.  Observe 
the  same  fragment 
recoveries  occur  simultaneously 
in 
then  each 
and 
of  the 
recovery  process  can  be  performed 
their  processing 
if  the  cycles  overlap, 
others.  However, 
in  the  following  manner.  When  a  node 
is  sequentialized 
it  does  not  for- 
is  involved 
ward  messages  received 
its  descendants)  about 
other  recoveries.  Such  a  node  stores  the  messages  until 
the 
time 
one  of  the  stopped  messages will  be  forwarded  upwards. 
journey 
recovery 
deadlock  situation  may  occur. 

their 
the  root,  could  get  stopped  by  other 

towards 
processes,  a  potential 

recovery  process  is  completed  at  which 

As  messages  of  one  recovery,  on 

in  processing  one  recovery, 

in  the  cycle  do  not 

cycles  are  disjoint, 

the  corresponding 

independently 

(i.e.,  links 

(from 

links 

first 

into 

recovery, 

lea(e)  and 

forward  at 

to  Fig  2,  both 

in  recovery  processing  will 

(Referring 
lca(e’)  will  not 
receive  messages on  one  side  of  the  cycle).  As  each  node 
involved 
least 
one  recovery  message,  the  root  of  the  fragment  will  be 
informed  of  at  least  one  recovery.  The  root  will  select 
for  processing,  by  sending  a, 
the  first  arriving 
the  same 
privilege  message  which 
path  on  which 
the 
to  release  the  stopped  messages.  (In  Fig.  2,  the 
cycle 
travel 
privilege  will 
to  v 
the  stopped  message  at  x).  After 
and  upwards 
releasing 
is  informed  of  the  com- 
the  cycle  is  updated, 
the  root 
the  recovery  pro- 
pletion. 
cessing  also  avoiding  any  deadlock.  More 
implementa- 
tion  details  are  given  in  section  4. 

recovery  message arrived  and  around 

the  root  sequentializes 

travels  down  over 

to  u,  and  then 

the  root 

Thus, 

from 

Fig.  2 

3.2.3. 
cess. 

Interaction 

of  Failure 

and  Recovery 

Pro- 

F  can  be 

A 

fragment 

outgoing  edge  and  concurrently 

minimum 
or  more  link 
As  long  as  no  tree  link 
complete  and  update  the  fragment  correctly. 

finding 
its 
process  one 
it,  as  described  earlier. 
in  F  fails,  all  the  processes  will 

recoveries  within 

involved 

in 

A  note  of  caution 

is  in  order.  A  node  should  not 
for  its 
consider  any  of  its  recovered  links  as  a  candidate 
is  engaged  in  testing 
minimum  outgoing  edge  when 
in  the  MST  being 
its  outgoing  edges,  as this  may  result 
in  Fig.  3,  links  e r  and  es  may 
incorrect. 
be  included 
if  recovered 
links  are  not  con- 
sidered,  whereas  e e should  be  included 

(For  example 
in  the  MST 

instead  of  es.) 

it 

When 

in  F  fail, 

tree  links 

then  each  new  fragment 
generated  can  again  process  the  failures  and  recoveries 
in  F  causes  the  nodes  u 
within 
and  v  of  a  link 
to  be  in  two  different 
then  the  recovery  process  of  e will  stop  until 
fragments, 

recovery  e=(u,v) 

it.  If  a  tree  link 

failure 

333 

a  REIDEN-ACK<id> 

with 

responds 

node 
which  will  be  sent  upwards 
ment 
root 

root.  When 
then  all  nodes  know 
To 

the  minimum 

to  the 

find 

from 

the 
this  message 
the  current 

outgoing 

message 
frag- 
the 

by 

leaves  of  the 
is  received 
fragment 
edge, 

identity. 
the 

root 

fifind  state  and  performs 
in  which 

the 

root  broadcasts 

another 

broadcast- 
a  FINDMOE 

fragment. 
into 

A  node 
find 

and 
message  over  each  of  its  non-tree 

state 

the 

receiving 

receives  such  a  message  may 
a  REJECT<id>, 

or  with 

this  mes- 
sends 
a 
links.  A 
respond  with  an 
which 
indi- 
is  outgoing. 

or  not 
id  sent  with 

response, 

the  non-tree 

link 

as  the 

the  TEST  message  must  be 
the 
is  the  same 

id  may  change 
The 

reason 

in 

failures. 

id  to  the  echo  in  every  broadcast-echo 
its  parent 

the  echo,  node  u  sends 

to 

>  message 

,  where  w, 

the  outgoing 

edge 

found 

by 

a  node  sends 

this  message 
root 
receives 

state.  When 

message 

from  all 

the 
its  children 

the  minimum 

outgoing 

edge 

this 

over 

root 

point 

the 
the  path 

that 
changes  occur, 
similar 

in  a  manner 

topological 

the  end  node  of  the  moe  receives 

a 
is  the 
the 
it 
a 

sends 

it  knows 
(or  moe)  of 
a 
to  the 

leads 
the 
resilient 
to  the  GHS 
the 
message 

fragments 

fragment 

to 

fragments, 

time  due  to  other 

in 

the 

the 

that 

also 

the 
the 

the 
enters 

enters 
with-echo, 
message  over 
sage 
TffST<id> 
node 
that 
ACCEPT<id> 
cates  whether 
(Note 
returned 
mean 
for  attaching 
phase).  During 
FINDMOE-ACK<id,w, 
minimum 
weight 
descendants 
enters 
the 
FINDMOE-ACK 
the  weight 
the 
CHANGE-ROOT<id> 
moe. 
then  proceeds 
protocol 
protocol, 
ie.,  when 
CHANGE-ROOT<id> 
to  over 
and  starts 
find  a  new  moe.  Note 
each 
choose 

of 
fragment. 

the  outgoing 

If  no  other 

finding 

At 

of 

of  u.  After 
found 

edge 
a  process  over 

it  sends  a  CONNECT 
two 

to  merge 
the 
if 

the 
“extended” 
there  are  m 

that 

then  at  least 
edge. 

its  own  moe, 

two  of  them  will 

the  same  outgoing 
that  other 
is  being  performed. 

topologicaI 

fails  and  u’ 

Such  a  failure 

divides 

As  explained 
fragments. 

message 
identity 
the  root 

failure 

process 

fragment. 

fragments. 

link  e’=(u’,v’) 

id’ 
is  the  new 
failure.  When 

Suppose 
this  process 
that 
the 
two  more 
the  root  of  one  of  the 
a  FAILURE<id’> 
where 
recent 
will 
last 
and 
failure 
doned 
failure 
messages 
fragment. 

a  new 
by  giving 

start 
failure 
finding 

contain 

that 

a  new 
a  new  outgoing 

process 
because 
has  now  been  divided. 

initiated 
by 
the  original 

the 

For 
instance, 
is  the  parent 

changes  occur  while 
assume 
in 
of  v’ 
into 
before  v’  will  become 
u’  will  send 
However, 

fragment 

the 

root  of  its  fragment, 

to  the 
corresponding 
receives  such  a  message 

to  the  most 
it 
the 

to 

to 

corresponding 
its  current 
edge.  Observe 
the 
failure  of  e  will  be  aban- 
that 
any 

fragment 
that 

A  node  will 

by 
ignore 

created 

fragment 

id 

the 

identity 

given 

to  the  original 

Fig. 

3 

fragments  merge  and  nodes  u  and  v  belong 

Conversely, 
recovered 
for 

fragment 

if 
links 

to 

the 
the  outgoing 
links  of  a 
then  only  one  of  them 
in 

as  described 

expansion, 

fragment. 

the 
same 
fragment 
will  be  selected 
detail 

are  all 

in  the  next  section. 

MST 

Protocol. 

4.  Description 

of 

the  Resilient 
In  this  section,  we  describe 
involved 
(A 

in  updating 

formal 

description 
initial  MST 

and 

the  MST, 

the  actions 

is  given 
is  a  directed 

taken  by  a 
the  messages 
It 
is 
tree. 
in  sleep  state.  First,  we  shall 
and 
and 

failure 
failures 

[3]). 
rooted 

courses  of 

in 

interaction 
is  described 

when 
later. 

the 

that 
all  nodes  are 
separately 
processes.  The 
in  time 
overlap 

the  normal 

node 
used. 
assumed 
Initially, 
describe 
recovery 
recoveries 

failure 

of  any 
recovered 

its  adja- 
it 
links, 

where 

node  u  is 
fails,  node  u  (in  sleep 

generated 

to  its  parent, 
by 
failure 

the 

4.1. 

Failure 
When 

Response. 

a  node  detects 

the 

cent  non-tree 
deletes 
simply 
Consider 

links 
it  from 
any 

or  unprocessed 

its  local  memory. 

tree 

link  e=(u,v), 

link 

id(e) 

If  this 

identity 

is  the  new 

the  parent  of  node  v. 
state)  sends  a  message  FAILURE<id(e)> 
where 
of  e  (as  explained 
propagated 
ing 
its 
marks 
and  also  enters 

this  message  enters 
identity 

to  be 
itself  as  the 
the 
Upon  entering 

id(e).  Node 
root 
(of  the 
reiden  state. 
the 

upwards 

reiden 
in  which 

phase 

broadcast-echo 
sage  REIDEN<id> 
nodes 
message, 
identity 

to  the 

in  the 

changes 

which 

travels 

fragment. 

Every 

node 
reiden 

to  the  root. 

in  section  3.2.1).  This  message  will  be 
receiv- 
into  a  reiden  state,  and  changes 
hand, 
v), 

v,  on 
fragment 

root  upon 

the  other 

containing 

The 

the 

root  enters  a 
state, 
the  mes- 
it  broadcasts 
the 
to  all 
receives  such  a 

down 
that 

tree 

its  state 

to 

and 

its 

fragment 

identity 

contained 

in  the  message.  Each 

334 

If  the  root  of  a  fragment 
going  edge  (i.e.,  either 
the 
network  or  it  is  disconnected 
work), 
the  and  enters  into 
such  a message will  also  into  the  sleep  state. 

finds  that 
there  is  no  out- 
fragment  spans  the  entire 
the  rest  of  the  net- 
it  broadcasts  a  GOSLEEP  message  over 
the  sleep  state.  A  node  that  receives 

from 

then 

of 

in  [3]). 

failures, 

4.1:  Corresponding 
there  is  no  recovery), 

the  protocol 
the  following  proposi- 

the  above  description 
for  link 

Based  on 
implementation 
tion  is  presented  (the  proof  can  be  found 
to  a  set  of  failures 
Prooosition 
(suppose  that 
if  the  final  graph 
is 
still  a  connected  graph,  then  the  tree  maintained  by  the 
protocol 
is  the  MST  of  the  final  graph  and  each  node 
returns 
if  the  final  graph 
to  the  sleep  state;  otherwise, 
in  each  connected  com- 
becomes  disconnected, 
ponent, 
the  MST  of  this  sub- 
graph  and  each  node  in  each  connected  component  will 
enter  the  sleep  state. 

the  protocol  maintains 

then, 

4.2.  Recovery 

Response. 

to 

to 

sends 

is  the 

Initially 

recover 

parents, 

and 
its 

that  detect 

the  message  is  simply 

link  e=(u,v). 
(with 

the 
messages  where 

at  each  node,  change  their  states 

Consider  a  recovered 
all 
nodes  are  in  a  normalstate 
respect  to  recoveries). 
The  end  nodes 
recovery,  exchange 
fragment 
id 
ID-CHECK<id> 
identity 
to  recover, 
and  send  a  RECOVERY<id,w(e),w(p)>, 
where  w(p)  is 
the  weight  of  the  link  going  to  the  parent.  A  node  that 
checks  if  the  frag- 
receives  a  RECOVERY<id,w(e),w> 
id  is  not  the  same 
ment  id  is  the  same.  If  the  fragment 
then  a  failure  has  happened  and  the  fragment 
is  being 
reidentified.  Thus 
ignored.  Con- 
versely, 
if  the  id  is  the  same  then  the  node  changes  its 
state 
wherz 
RECOVERY<id,w(e),w’> 
where  w(p)  is  again  the  weight  of  the 
w’=max{w,w(p)} 
to  the  parent  of  the  node.  This  process  is 
link  going 
least  com- 
continued  until 
lca(u,v).  This 
mon  ancestor 
message  from  u  and 
node  will 
first. 
from  v.  Suppose  that 
Then 
the  RECOVERY 
the 
parent  of  the  lea  node  as  explained  above.  Conversely, 
the  message  from  u  will  not  be  forwarded. 
it 
will  be  stopped  at  the  lea  or  further  action.  When 
the 
root  receives  the  RECOVERY<id,w,w’> 
message from 
a  child 
mes- 
sage  which 
the  serial- 
ization  of  the  recoveries  (see Section  3.2.2).  If  this  mes- 
sage  reaches  the  lca(u,v)  after  the  second  RECOVERY 
from  v  then 
because  no  serialization 
second  RECOVERY 
then 

to  the  root 
if  the 
message  has  not  been  received 
the 

it  responds  with  a  PRIVILEGE<id,w,O> 
functions  as a  token  that  permits 

the  message  arrives  at  the 

message  is  forwarded  over 

the  message  from  v  arrives 

of  u  and  v,  denoted  by 

is  necessary.  Conversely, 

message  is  forwarded 

receive  a  RECOVERY 

this  PRIVILEGE 

the  PRIVILEGE 

is  returned 

Instead 

to 

If 

lca(u,v) 

over  the  appropriate  path. 
the 

the  node  will 

reaches  a  node 

that  has 
message  (i.e.  because  another 
release  the 
lca(u,v). 
the 
to  the  root. 
the  root  will  send  a  new 

reach 
will 
is  returned 

this  point 

is  another 

the  PRIVILEGE 

the  RECOVERY 
is  taking  place)  then 

cycle. 
stopped 
recovery 
message  and  the  RECOVERY 
the  PRIVILEGE 
At 
If  there 
recovery, 
PRIVILEGE 
finally 
When 
messages  it  starts 
RECOVERY 
replace  the  edge  in  the  cycle  with 
To  do  this, 
cycle. 
the  link  with 
link  as a  non-tree 
forwards 
hand,  a  node  that 
maximum  weight  will  change 
forward 
the  original  REPLACE 
receives  a  REPLACE<id,w(e),oo> 
parent-child 

a  REPLACE<id,w(e),oo>. 
is  not  adjacent 

If  the  node  receiving 

the  message  is  adjacent 
it  marks 

two 
the  process  that  will 
the  maximum  weight. 
over  the 
to 
the 
link,  changes  its  state  to  normal,  and 
the  other 
the 
to  normal  and 
message.  A  node  that 
the 

to  the  link  with 

it  sends  a  REPLACE<id,w(e),w> 

the  maximum  weight 

its  state 

receives 

relation. 

reverse 

then 

the 

On 

will 

It  should  be  clear 

that 

in 

the 

implementation 

described  above,  the  recovery  processes  proceed  sequen- 
tially  as suggested  in  Section  3.2.2. 

of 

the 

link 

recoveries, 

is  presented  (the  proof  can  be found 

4.2:  Corresponding 
there  are  no  failures), 

the  above  description 
for 

the  protocol 
Based  on 
following 
the 
implementation 
in  [3]). 
proposition 
to  a  set  of  recoveries 
ProDosition 
if  the  final  graph  is 
(suppose  that 
then  the  tree  maintained  by  the 
still  a  connected  graph, 
is  the  MST  of  the  final  graph  and  each  node 
protocol 
to  sleep  state;  otherwise, 
returns 
final  graph 
in  each  connected  com- 
becomes  disconnected, 
ponent, 
this 
subgraph  and  each  node  in  each  connected  component 
also  enters  sleep  state. 

the  protocol  still  maintains 

the  MST  of 

then, 

the 

if 

of  Failures 

and  Recoveries. 

4.3. 

Interaction 
Suppose 

that  a  node  u  is  the  Cca of  an  ongoing 
assume  that  u  is  also 
in  a  failure  process.  Then  u  will  hold  the 
the  failure  process  is  finished. 
that  a  failure  process  may  cause 
this  only  hap- 

recovery  process.  Furthermore, 
participating 
REPLACE 
Note  that 
a  delay  in  the  recovery  process.  However, 
pens  in  some 

message  until 
this 

instances. 

implies 

Suppose  now  that  one  of  the  link 
recovery  process  fails.  Then 

ongoing 
fragment  will 
generated  by 
they  will  contain 
recovered 
they 
nodes  can  “remember” 

in  the  cycle  of  an 
the  nodes  in 
the 
and  the  messages 
recovery  will  be  discarded  because 
the  old  identity.  The  end  nodes  of  the 
link  will  start  a  new  recovery  process  (after 
the  end 
link 

identities).  Note 
the  recovery  because  the 

receive  a  new  identity 
the 

their  new 

receive 

that 

335 

defined  on  G&  , which 
of 

the  correctness 

includes 
the  protocol 

Now, 

(u,v).  0 

can  be  esta- 

link 

fragment 

(u,v)  was  a  recovered 

link  at 
and 
formed  by  adding 
than 
before 

time 
is  a  tree 
there 
into 
this 
(u,v) 
the  weight 
the 
there  are  only 

link  before 
t.  Then,  either 
link 
frag- 
of  (u,v>, 
of 
links 
node  u,  to  other 

installation 
recovered 

is  greater 

including 

first  case,  due 

there  are  simultaneous 
the  weight 
(u,v) 
induced 

is  with 

link 

of 

to  Proposition 
recovery 
less  than 
subgraph 
by  y,  assuming 

fragment 
of  y.  Thus,  based  on  Proposition 

the 
rooted 

the  MST  of  G&  which 

case, 
a  tree 
the  of 

(u,v)  will 
link  at 
the 

includes 
be 
time 
induced 

(u,v)  at 
the  only 
t.  Thus, 
subgraph 
node  u.  There- 
the  com- 

of 

to  the 
case, 

fragment 
(u,v) 

including 

is  in 

the  MST 

has  been  deleted 

link;  or 

the  component, 
of  G&. 
In  the 

that 

Suppose 
t  and  becomes  a  tree 
is  inside 
in  the  cycle 

some 

(x,y) 

time 
(u,v) 
(x,y), 
ment,  whose  weight 
and 
(u,v)  as  a  tree 
connecting 
components 
4.2  which 
and 
failure 
any  outgoing 
corresponding 
that 
3.1  (u,v) 
time 
t. 
recovered 
(u,v) 
is 
corresponding 
fore, 
ponent, 

in  either 

x 

is  the  parent 

holds  when 
processes, 

non-tree 
to 
the 

the 

is  in 
In 
second 
link  becoming 
the  moe  of 

Since 

of  the 

the  notification 

link  will  arrive  at  the 

the  connection 
where 

failure 
the  moe  which 

fragment 
disconnected. 
the  case  that 

blished. 
Theorem 
each  component 
Proof: 
any 
there  exists 
the 
finds 
process  and 
t,  or 
the 
becomes 
Also, 
in 
the  outgoing 
only  one  of  them, 
two 
finite 
time  after 
be  one  spanning 
graph. 
recovered 
implies 
tree 
no  deadlocks 
a  time 
to  be  the  maximum 
fact, 
> 
holds 
spanning 
is  an  MST  of  that  component 

recovered 
link 
(as  described 
t,  s.t.  G&  =  GL 

link  or  a  non-tree 

say 
including 

throughout 

ts.  This 

Therefore, 

link  will 

fragments 

each 

that 

5.1:  The  algorithm 

constructs 

an  MST 

for 

final  graph. 

of  topological 

two  end  nodes 

in  finite 

change  on 
time, 
t  r.  Besides, 
t  only 
it 
failure 
time 

if 

done  at 

t  r  s.t.  GL  =  G,! 
process  will 

terminate 

for  all 
at 

t  > 
time 

is  not  selected  by  any  other 

is  successfully 

this 

failure 
with 
ail  other 
there  are  only 

edges  of  some 

fragment, 

process  originated 
fragments 
recovered 
then 
to  merge 

(u,v),  will  be  used 

u  and  v  respectively. 
topological 
change 

last 

the 
tree  on  every 
that 
inside 

from 
be 

component 

time 
some 

of 
onward, 
fragment. 

link  will  either 

time  since 

in  finite 
in  Section  4.  Hence, 
for 
of  t  r  and 

time 
t 2.  If  we 
t2,  then  GE  =  Gb 

t  > 

combined 
the  computation, 

with  Property 

will 

imply 

the 

Thus, 

in  G&. 
links  as 
one  and 
the 
in 
there  will 
final 
every 
This 
become 
a 
there  are 
is 
t, 
t 

there 
let 

for 
5.1  which 
the 
t, 

t  > 

that 

tree  T  on  each  component 
of  the 

for 

of  G& 
final  graph.  q 

remains 

unclassified. 

We  have 

described 

how  a 

recovery 
affect  a  failure 

process. 

However, 

a  link 

process  as  follows. 

failure  may 

a 
recovery  may  also 

affect 

hold  any  message 
topology 

the 

These  messages  will 

its 

for 

return.  At 

Ica  node  has  sent  a  REPLACE 
the 
time 
over 
the 
is  being 
the 
that 
it 

this 
travel 
cycle 
sent  when 
a  node 

that  will 
the 
be 

Similarly, 

of 

is  returned. 

lea  will  hold  any  FAILURE  message  when 

in  a  recovery 
is  being  changed 

process  because 

the 

topology 

and 

the  parent-child 

rela- 

because 

that 
an 
is  waiting 

Assume 
message  and 
node  will 
cycle 
adjusted. 
REPLACE  message 
is  not  an 
is  involved 
of  the  cycle 
tions  are  being  changed. 
It  can  be  observed 
failures 
l 

still  hold  when 
ously 
(see  [3]). 

that  Propositions 

4.1  and  4.2 

and 

recoveries 

occur  simultane- 

5.  Proof  of  Correctness. 

we  briefly 

outline 

the  correctness 

In 

the 

(x,y) 

at  all 

following, 
proof  of  the  protocol. 
Let  Gj  denote 
the 

to  be  the 

and  E(G&) 

times). 
network, 
network  without 

the  nodes  and 
Define  Gi 
information 
the 
words,  a  link 
have 
recorded 
the  delays 
identical 
computational 
logical 
=  V(Gi) 
in  R  t 
it  as  a  recovered 
ProDertv 
if  a  link 
(u,v) 
is 
includes 
Proof: 
before 
due 
mixture 
described 
specific 
on 
the 
MST  of  the  component, 
(u,v). 

(u,v) 
in 
(u,v). 
Suppose 

to  Proposition 
failure 

edge. 
5.1:  At  any 

the  MST 

time 

that 

of 

stored  at  each  node  at  time 

is  in  CL 

links 

that  are  operational 

the  physical 

logical 

time 

network 

network 

corresponding 

at  time 
at 

t  i.e., 
t. 
to 
t.  In  other 
if  both  node  x  and  node  y 
to 
Gj  and  GL  may  not  be 
to  define  a 
the 

as  GE,  which 

(Note 

that, 

due 

is 

links 

i.e.,  V(G&) 
-  R  t,  where  an  edge 

is 

It 

is  also  convenient 
denoted 
the 

recovered 

=  E(Gi) 

(x,y)  as  operational. 

in  the  notifications, 

if  either  or  both  of  its  end  nodes  have 

recorded 

time 

t  during 

the  computation, 

is  classified 
of 

as  a  tree 
the  component 

link  by  node  u,  then 
of  GE  which 

t  and  becomes  a  tree 

link 
t.  Then, 
there 

link 

(u,v)  was  a  non-tree 

link  at 

recovery 

time 
4.1  which  holds  even  when 
processes  and 

is 
processes  as 
(u,v)  must  be  an  moe  of  some 
based 
the 
in 
includes 

Therefore, 
is 

defined  on  G&,  which 

(u,v) 

in  section  4.3, 

set  of  nodes  defined  on  G&. 
fragment 
property, 

expansion 

1  Also 
between 

see 

(3) 

for  a 

further 

discussion 

on 

the 

interactions 

failure  and  recovery  processes. 

336 

6.  Complexity 

Analysis. 

References 

that 

the  FAILURE 

Suppose  that 

the  new  identity 

message  travels  over 

the  network  has  n  nodes  and  e edges. 
Moreover,  assume  that  a single  failure  occurs.  It  can  be 
noted 
the 
broad- 
edges  of  a  tree  with  O(n)  messages.  Similarly, 
casting 
the 
require  O(n)  mes- 
new  moe,  and  merging 
sages  since  these  activities 
the  edges  of 
are  done  over 
the  tree.  However, 
the  minimum  outgoing  edge 
to  find 
fragments,  messages  need  to  be  sent  over  O(e) 
of  the 
non-tree 
for  a  sin- 
gle  failure 

the  message  complexity 

is  O(e)  messages. 

the  fragments 

links.  Thus 

fragment, 

of  the 

finding 

Suppose  now  that  a  single  recovery  occurs.  As  in 
links  of 
links  are  traversed.  Therefore, 
is  O(n)  messages. 

the  above  case,  the  messages  travel  only  over 
the  tree  and  no  non-tree 
the  complexity 

for  a single  recovery 

failures 

As  mentioned 

in  previous  Sections,  some  of 

to  find  its  moe  is  lost.  Therefore, 

the 
of  a  failure  or  a  recovery  may  be  lost  because 
activity 
(see  Sections  4.1  and  4.3). 
of  subsequent 
Nevertheless,  when  a  link 
failure  occurs  within  a  frag- 
ment  F,  it  suspends  any  failure  process  in  progress  in  F 
as  well  as  the  concurrent 
recovery  processes  in  F  (if 
any)  and  a  completely  new  process  is  started.  Note  that 
failure  processes,  the  effort 
for  each  of  the  suspended 
the  messages 
devoted 
lost  are  bounded  by  2ef6n.  Similarly, 
suppose  that  all 
suspended 
in  dis- 
joint  cycles  of  the  fragment.  Then 
the  messages in  each 
traverse  on  the  links  of  the  relevant  cycle. 
process  only 
Thus, 
the  total  number  of  wasted  messages  is  at  most 
the  protocol  uses  only  O(me+kn)  mes- 
3n.  Therefore, 
for  the  final  graph  where 
sages  to  reconstruct  an  MST 
m  and  k  are 
failures  and 
recoveries  respectively.  Note 
that  e  and  n  refer  to  the 
maximum  number  of  edges  and  nodes  in  the  graph  dur- 
ing  the  computation. 

recovery  processes  are  taking  place 

the  numbers  of 

tree 

link 

the  cycles 

The  best  case  message  complexity 

O(n)  when 
disjoint.  The  best  case  message  complexity 
is  O(e)  when  all 
different 

is 
these  recoveries  are 
for  failures 
the  fragments  except  one  choose  the 

for  recoveries 

formed  by 

links  as their  respective  moe. 
case  time  complexity 

that 

(evaluated 

The  worst 

it  takes  one  time  unit 

link) 
the  computation. 

assuming 
across  any 
used  during 
plexity 
height  among  the  fragments  created  during 
tation. 

to  O(H)  where  H 

by 
to  send  a  message 
to  number  of  messages 
The  best  case  time  com- 
the  maximum 
the  compu- 

is  also  equal 

is  equal 

is 

Weight 

Spanning 

Evanston, 

University, 

a  Minimum 

to  Maintain 

in  Multihop 

and  S.  Even, 

in  a  Dynamic 

and  S.  Kutten, 

Radio  Networks,” 

“A  Resilient  Distri- 

“An  Almost  Linear  Time 

“A  Protocol 
Tree 

“Optimal  Distributed  Algorithm 

Topology,”  M.S. 
IL, 

for 
Tree,  Counting, 
Symp. 

“Reliable  Broadcast 
in  Unreliable  Networks,”  Networks,  vol. 

Algorithm 
Spanning  Trees,”  26th  Symp. 
of  Comp.  Sci.,  pp.  257-266,  Port: 

“Tree-Based  Broad- 
IEEE 
on  Comp.,  vol.  C-36,  no.  10,  pp.  1209-1223, 

B.  Awerbuch 
Protocols 
16,  no.  4,  pp.  381-396,  Dec.  1986. 
B.  Awerbuch, 
Minimum 
Leader  Election, 
and  Related  Problems,” 
Theory  of  Comp.,  pp.  230-240,  May  1987. 
C.  Cheng, 
Spanning 
Thesis,  Northwestern 
June  1988. 
F.  Chin  and  H.F.  Ting, 
and  O(nlogn+e)  Messages  Distributed 
for  Minimum-Weight 
on  Foundations 
land,  OR,  Oct.  1985. 
I.  Chlamtac 
casting 
Trans. 
Oct.  1987. 
LA.  Cimet  and  S.P.R.  Kumar, 
for  Network 
buted  Protocol 
ACM  SIGCOMM 
and  Pro- 
Symp.  Commun.  Arch. 
tocols,  pp.  358-367,  Stowe,  VT,  Aug.  1986.  Also  in 
Computer  Communications  Review, 
vol.  16,  no.  3. 
“A  ResiIient  Distri- 
LA.  Cimet  and  S.P.R.  Kumar, 
buted  Algorithm 
Spanning 
Proc.,  pp.  196-203, 
Trees,” 
St.  Charles, 
Y.K.  Dalal  and  R.M.  Metcalfe, 
“Reverse  Path  For- 
warding  of  Broadcast  Packets,”  Commun.  ACM, 
vol.  21,  no.  12,  pp.  1040-1048,  Dec.  1978. 
N.  Francez, 
Termination,” 
TOPLAS, 
E.  Gafni, 
of  Two  Message-Optimal  Election  Algorithms,” 
ACM 
175-185,  Minaki,  Ont,  Canada,  Aug.  1985. 
R.G.  Gallager,  P.A.  Humblet,  and  P.M.  Spira,  “A 
Distributed  Algorithm 
for  Minimum  Weight  Span- 
ning  Trees,”  ACM 
Lang.  Syst., 
vol.  5,  pp.  66-77,  Jan.  1983. 
R.  Perlman, 
111-111,  asfasfsaf,  date. 
A.  Segall,  “Distributed 
Trans. 
Jan.  1983. 

vol.  2,  no.  1,  pp.  42-55,  1980. 
“Improvements 

IEEE 
IT-29,  no.  1,  pp.  23-35, 

4th 
of  Dist.  Comp.,  pp. 

in  the  Time  Complexity 

Int’l  Con/.  on  Parallel 

Network  Protocols,” 

for  Minimum-Weight 

Synchronization,” 

IL,  Aug.  1987. 

Trans.  Program. 

on  Principles 

“Distributed 

Inf.  Theory, 

‘&Gateway 

routing,” 

safasasf, 

Symp. 

ACM 

pp. 

vol. 

1. 

2. 

3. 

4. 

5. 

6. 

7. 

8. 

9. 

10. 

11. 

12. 

13. 

337 

APPENDIX: 
Algorithm 

Formal 

Description 

of 

the 

Resilient 

This  appendix  presents  a  brief  formal  description  of  the 
is 
the  messages  and 
that  some 

:haL  the  reader 
used  in  the  GHS  algorithm.  Also  note 

(for  a  complete  description 

is  familiar  with 

resilient  protocol 
assumed 
variables 
trivial  parts  are  omitted. 

see  [31). 

It 

for  link  (u,v). 

end  when 

if  f-state=reiden 

or  f-state=jindmoe 

send  FAZLURE<fid> 
if 

to  parent. 

then 

if 

end 
if 

end 

over  (u,v). 

else 

(1)  Response  of  node  u  to  failure  notification 
if  (u,v) 

is  a  tree  link 

then 
generate  new  fragment 
if  u  is  a  child  of  v  then 

identity 

lid. 

u  becomes  the  root  of  fragment. 
f-state+reiden. 
idtfid. 
send  REIDEN<id> 

to  all  children. 

if  f-state=jound 

then 

hold  FAILURE  message. 

else 

else 

end 
if 

end 
if 

end 

(2)  Response  of  u  to  FAZLCJRE<fid> 
if  u  is  root 
idtfid; 
send  REZDEN<id> 

then 

to  all  children. 

else 

end 

send  FAZLURE<fid> 
if 

to  parent. 

(3)  Response  of  u  to  REZDEN<fid> 
idcfid. 
f-state+-reiden. 
if  u  has  no  children 

then 

send  REZDEN-ACI(<id> 

to  parent. 

else 

end 

send  REZDEN<id> 
if 

to  all  children. 

(5)  Response  of  u  to  FZNDMOE<fid> 
if  id=fid 

then 

over  (u,v). 

use  TEST<id> 
if  u  has  no  children 

then 

to  find  all  incident  outgoing  edges. 

send  FZNDMOE-ACK<id,moe> 
(moe  is  the  local  moe  of  u) 

to  parent. 

send  FZNDMOE<id> 
if 

to  all  children. 

(6)  Response  of  u  to  FZNDMOE-ACK<fid,e> 
if  id=fid 

then 

over  (u,v). 

if  u  is  leader  then 

send  CHANGE-ROOT 

to  child  who  reported  moe. 

else 

end 

else 

if  u  received  FZNDMOE-ACK 

from 

every  child 

then 

send  FZNDMOE-ACK<id,moe> 

with 

local  moe. 

to  parent 

over  (u,v). 

(7)  Response  of  u  to  CHANGE-ROOT<fid,e> 
let  a  child  of  u  be  the  parent. 
if  e is  an  incident 

link 

send  CONNECT 

then 
over  moe. 

send  CHANGE-ROOT 

in  FINDMOE-A 

CK. 

to  child 

that 

reported  e 

end 

if 

(8)  Response  of  u  to  recovery  notification 
if  u  and  v  are  in  the  same  fragment 

then 

for  (u,v). 

(9)  Response  of  u  to  RECOVERY<fid,w,w’> 
if  u  received  a  RECOVERY  message  from  node  x 

over  (u,v). 

for  the  same  recovery 

then 

wait 

until  u  has  received  echo  then 

send  REPLACE 

to  child  reporting  maximum  weight 

over  (u,v). 

end 

send  RECOVERY 
if 

to  parent. 

(4)  Response  of  u  to  REZDEN-ACK<fid> 
if 

id=fid 

then 

if  u  received  REZDEN-AQZ<<fid> 

over  (u,v). 

from  every  child 

the1 

end 

end  wait 
if 

if  u  is  leader  then 

send  FZNDMOE<id> 
f-state+-find. 

to  all  children. 

else 

end 
if 

end 
if 

end 

send  REZDEN-ACZ(< 
if 

id > 

to  parent. 

338 

A  Protocol 

to  Maintain 

a  Minimum 

Spanning 

Tree 

in  a  Dynamic 

Topology 

* 

C.  Cheng, 

I.A.  Cimett, 

and  Srikanta  P.R.  Kumar 

Electrical 

Engineering 

and  Computer 

Science  Department 

Northwestern 
Evanston, 

University 
IL  60208 

Abstract 

We  present  a  distributed 
a  minimum-weight 
with 

changing 

protocol 

for  updating 

spanning 

tree 

(MST) 

topology. 

The  protocol 

and 
in 
can 

to  multiple 

link/node 

failures 

can  occur  at  arbitrary 
finite  number 

of  topological 

times.  Given 

the  protocol 

network, 

The  message 
h w  en 
occur,  where 

links, 

within 

finds 

the  MST 
finite 
complexity 

link 
k 
IV1  and 
respectively. 

recoveries 
[El  are 

and 

recoveries 
that  an  arbi- 
changes  occur  during 
to 
last 
is 
link 
number 

corresponding 
the 
protocol 
and  m 
total 

time 
of 

after 

the 

the 

maintaining 
a  network 
respond 
that 
trary 
a  period, 
the 
change. 
O(+l+klW 
failures 
of  nodes  and 

latest 

1. 

Introduction. 

A 

spanning 

tree 

a  minimally 

represents 
all 
the  nodes 
in  point-t-point 
casting 
ascertain 
termination) 
local-area 
multihop 

[8], 

in 

the  network. 
networks 

in  selecting 

certain 

conditions 
[9].  Spanning 

Such 

of  a  communication 
connected 
structure 

network 
containing 
trees  are  employed 
for  efficient  message  broad- 
to 
or 
in 
in 

trees  have  also  been  used 
[12]  and 

(e.g.:  mutual 

processor 

a  ‘leader’ 

exclusion 

routing 

[lo], 

or 

networks 

for  gateway 

radio  networks 

for  bandwidth 

a  cost  or  weight 
fees  or  delay) 

is  associated 

with 

allocation 
(representing, 

[5]. 

In  general, 
usage 
the 

network. 

example, 
links 
of 
whose  edges  have  minimum 
the 
Minimum-Weight 

tasks  mentioned 

Spanning 

Therefore, 
weight 
This 

above. 

the 
is  usually 
tree 

spanning 

needed 

is  called 
(MST).  One  of 

Tree 

for 
the 
tree 
in 
the 
the 

*  This  work  was  supported 

in  part  by  grants  from  US-WEST 

Advanced  Technologies, 

and  from  Bell  Northern  Research. 

fee all  or  part  of  this  material  is granted  provided 
for  direct  commercial  advantage, 

Permission  io  copy  without 
that  the  copies  are  not  made  or  distributed 
the  ACM  copyright  notice  and  the  title  of  the  publication  and  its  date  appear, 
and  notice  is given  that  copying  is by  permission  of  the  Association 
Computing  Machinery.  To  copy  otherwise,  or  to  republish,  requires  a fee and/ 
or  specific  permission. 

for 

for 

point-to-point 

as  the  GHS  protocol) 
[ll]. 

and  Spira 

in 

the  GHS  protocol 

II&works 
was  presented 
In  a  network 
transmits 

MST 

denoted 

Humblet, 

protocols 

first 
(hereafter 
by  Gallager, 
of  n  nodes  and  e  edges, 
O(nlogn+e) 
uses  O(nlogn) 
protocol 

messages,  with  O(logn) 

bits/message, 

time  units. 
has  been  recently 
the  most  part,  protocols 

(The 
improved 

For 

time  complexity 
(2,  4,  lo]). 

run  over  a  communi- 

and 
of  this 

changing 

topology. 

additions 
the  course  of 

and  deletions 

time. 

Hence,  many 

past 

in  spite  of  topological 
the 
called 
protocol 

resilient 

decade 

the  MST 

for 

or 

The  changes 

in 
of  nodes  and 

protocols 
changes  have 
[1,  6,  131). 
In  par- 
was 

problem 

(e.g.: 
reliable. 

entail 

to  run 

cation  network  with 
topology 
links  over 
that  are  able 
been 
designed 
These  protocols 
ticular, 
proposed 
In 

a  resilient 
in  171. 

in 
are 

this  paper,  we  present 

a  new 

in 

time 

it  will  be  shown 

(i.e.:  a 
is  being 

to  topological 
recoveries, 

of  topological 
a  period 

buted  MST  protocol.  Given 
col  responds 
lfailures 
and 
failures/recoveries 
overlap 
while 
another 
finite  number 
times  during 
period), 
the  MST 
finite 
link 
0(  kn+me) 
trast, 
struct 
sage 
O(logn) 
more 
MST 
with  O(e)  bits/message. 

if  one  uses  a  protocol 
the 
complexity 

corresponding 
the 
and  k 
messages, 

tree  after  every 

efficient 
protocol 

time 
failures 

bits/message. 

last 
link 

after 

will 

to 

an  initial  MST, 

changes  caused  by 

resilient 

distri- 
the  proto- 
link/node 
the  MST.  Multiple 

and  updates 

simultaneously 
can  occur 
failure 
recovery 
or 
processed). 

Assuming 

or 

can 
can  occur 
a 

that 

changes  occur  at  arbitrary 

(and  no  more  changes  after 

this 
the  protocol  will  obtain 
latest  network 

that 
the 

topological 
recoveries, 

each  with  O(logn) 

failure 

(such  as  GHS) 
or  recovery, 
be  O((m+k)*(nlogn+e)), 
presented 
than 

the 

uses  O((m+k)*n) 

The  protocol 
for  dense  networks 
in 

[7]  which 

within 

a 
change.  Given  m 
the  protocol 
uses 
In  con- 
to 
recon- 
the  mes- 
with 

bits. 

is 

herein 
resilient 
messages 

The  paper 

is  organized 

as  follows. 

The  distributed 

computation 
Section 
theoretic 
buted 

and 

2.  Section 
properties 

communication 
3  ‘expiains 
and 

model 

the 

underlying 

are  given 

in 
graph 
of  the  distri- 
the 
resilient 

the  main 
Section 

features 
4  describes 

implementation. 

o 

1988  ACM  O-89791-279-9/88/008/0330 

$1 SO 

t  LA.  Cimet  was  with 

the  EECS  Dept.,  Northwestern 

ty.  He  is  now  with  AT&T  Bell  Laboratories, 

Naperville, 

Universi- 
IL,  60566. 

330 

MST  protocol.  Section  5  presents  a  sketch  of  I IIC proof 
of  correctness.  Finally,  Section  6  contains 
the  complex- 
ity  analysis. 

2.  Computational 

Model. 

is 

identity 

number, 

involving 

where  V 

for  the  protocol 

The  environment 

is  a  computing  unit 

queue  with  unlimited 

(u,v),  assigned  with  a  weight  w(u,v), 

is  an  asynchrc+ 
represented  by  an  undirected  weighted 
the  set  of  nodes  and 
is  the  set  of  links.  Each  node,  assigned  with  a 

nous  network 
graph  W,E), 
ECVXV 
unique 
a  processor,  a  local  memory,  and  also  an  input  queue 
capacity.  Each 
and  an  output 
link 
is  a  bidirec- 
line  connecting  nodes  u  and  v. 
tional  communication 
(the  iden- 
Each  node  knows  only 
its  local  environment 
tity  and  the  weights  of  its  links)  and  follows 
the  same 
protocol  which  consists  of  sending  and  receiving  mes- 
sages  over 
these 
messages.  The  received 
in  the 
input 
basis,  and 
are  also  processed  in  that  order. 

links,  and  processing 
(sent)  messages  are  put 

queue  on  a  first-in-first-out 

the  adjoining 

(output) 

link 

and 

the  link 

transmitted 

is  functioning, 

A  communication 

transmission.  When 
independently 
they  arrive  at 

in  a  dynamic  network  has 
the  following  properties.  Messages  can  only  be  sent  and 
received  over  a  link  which 
is  functioning.  However,  a 
message  need  not  arrive  at  the  receiver,  as the  link  may 
fail  during 
in  both 
messages  can  be 
the  other  end  after  a 
directions, 
in 
finite 
fails  or  recovers,  both  ends 
sequence.  Whenever  a  link 
finite 
the 
are  notilied 
in 
the  time  when  a  link  recovers,  there  are 
same  time.  At 
it,  nor  are  there  mes- 
no  messages  in 
sages  waiting 
to  be  sent  over  it  (i.e.,  all  messages  sent 
out  for  transmission  on  a  link  are  deleted  after  the  link 
fails).  Observe  that 
these  properties  are  commonly  used 
in  the  literature 

time  but  not  necessarily  at 

delay,  without 

(see  [  1,  131). 

undetermined 

through 

transit 

error 

and 

3.  The  Resilient 

MST 

Protocol. 

a 

of 

of  all 

a  finite 

Assume 

that  a  graph  G(V,E) 
its  MST.  Furthermore, 

the 
finite 

find,  within 

links 
number 

change,  an  MST 

along  with 
weights 
Thereafter, 
recoveries  occur  at  arbitrary 
col  must 
logical 
graph. 
Definition 
cal  change  in  the  network,  where 
ti 
the  change  occurs  and  ei  is  the  link 
ers  at 
recovery,  and  Ei,,=Ei-{ 
E,=E. 

Let  Ei+,= 
ei } 

3.1:  Let  Ci =<ei 

define  Vi 

Similarly, 

time. 

that 

is  given 
suppose 

initially 
that 

are  distinct 

(see 
failures 

the 
[ll)). 
and 
times.  The  resilient  proto- 
the  last  topo- 
to 
latest 

time  after 
corresponding 

link 

the 

,ti  >  be  the  i-th 

topologi- 
is  the  time  when 
fails  or  recov- 
is  a 
is  a  failure,  with 
to  be  the  set  of  nodes  in 

that 
EiU{ei} 

if  Ci 

if  C; 

the  graph  after  Ci.  Then 
the 
Si  =G(  Vi  ,Ei  ). 

topological 

i-th 

the  surviving 
change 
is 

net,ulork  after 
denoted 
by 

Suppose  that  only  k  topological 

the  network.  Then, 
an  MST 

for  Sk . 

the  distributed 

changes  occur 

in 
algorithm  must  find 

Properties. 

3.1.  Underlying 

Graph 
Before  the  distributed 

Theoretic 
implementation 

is 

in 

involved 

responding 

is  described, 
link 
we  outline  what 
theoretic  proper- 
failures  and  recoveries,  and  the  graph 
ties  underlying 
These 
properties  will  be  the  basis  for  the  collective  action  of 
the  nodes  involved 
process.  For 
notation  will  be  adopted. 
convenience, 
the 
Given  a  tree  T, 
denote 
the  deletion  and  addition  of  edge  e to  T. 

following 
let  T-e  and  T+e 

in  a  failure/recovery 

the  reconstruction 

of  the  MST. 

respectively 

to 

this 

link, 

then 

fails. 

If  e  is  a  non-tree 

First,  consider  a  single 

then  T’=T 
is  needed.  Conversely, 
two 

failure.  Let  T  be  the 
link 
to  the  failure,  and  let 
MST  of  the  graph  G(V,E)  prior 
link 
T’  be  the  MST  of  G(V,E-{e}),  where  eEE  is  the 
and  no 
that 
if  e  is  a 
updating  of  the  MST 
tree  link, 
fragments 
T  r  and  T,.  These  two  fragments  must  be  reconnected, 
if  at  all  possible, 
observed 
weight 
(see  (71).  (If 
then 
nected). 

the  new  MST. 
where  e’  is  the  minimum 
link  connecting  a  node  in  T  1  to  a  node  in  T, 
T  r  and  T,, 
is  discon- 

is  no  link  connecting 

failure  splits  T  into 

that  T’=T-e+e’, 

the  graph 

It  can  be 

to  obtain 

resulting 

failure 

there 

from 

the 

the  MST 

for  the  moment), 

(assume  no  recoveries, 

graph.  Hence,  starting 

Now,  when  there  are  many,  possibly  simultaneous, 
the  ini- 
is  broken  down  into  many  fragments.  Each  of 
is  also  a  fragment  of  the  MST  of  the 
these  frag- 
for  the  final  graph  can  be  constructed 
these  fragments,  whose 
of 
later)  will  be 

failures 
tial  MST 
these  fragments 
final  surviving 
ments, 
by  finding 
weight 
the  response 
based  on  this  idea,  and  being  so,  this  part  of  the  proto 
the  fixed-topology  MST 
co1 has  many  similarities  with 
there  are  some  impor- 
protocol  of  GHS  (111.  However, 
tant  differences,  and 
the  next 
section. 

is  minimum.  The  distributed 

the  links,  connecting 

these  are  explained 

implementation 

(described 

failures 

from 

link 

to 

in 

To  understand 

the 

consider  a  single 
the  recovered 
T’=T+e. 
then 
this 
graph, 
with 

the 
the  existing 

there 
recovery). 

then 

recovery. 
is  not 

link 

(If  both  ends  are  not 
is  no  spanning 

response 

to  a  link 

the  original  graph, 

recovery, 
If  one  of  the  end  nodes  of 
in 
then 
in  the  original  graph, 
from 
the  original 
forms  a  unique  cycle 
following 

for  the  graph  resulting 

proposition 

If  both  end  nodes  are  in 

recovered 
tree  links.  The 

link 

331 

initiates 

of  a  link 

to  update 

final  MST.  Each  of  the  end  nodes  detecting 

or  across  fragments,  and  the  appropr;;,  t.e cycle 
within 
the  fragment  and  obtain 
has  to  be  identified 
the 
the 
a  response  process, 
failure/recovery 
involve  several  other  nodes  in  the  task  to  be 
which  will 
in 
accomplished.  Such  response  processes  may  overlap 
in  more  than 
the  sense  that  a  node  may  be  involved 
one  of  them  at  the  same  time.  Before  we  present 
the 
description  of  the  protocol,  we  briefly  outline  some  of 
the  main  features  of  each  of  the  response  processes  and 
their 

interaction. 

3.2.1.  Response 

to  a  Link  Failure 

A 

[ll]. 

the 

the 

[ll]). 

(see 

arise 

failure 

failure 

identity 

fragment 

fragment 

to  which 

response 

in  nature 

the  initiated 

In  changing 

in  attempting 

issue  concerns 

first  assign  a  unique 

The  response  to  a  link 

the  failures  break  the  MST 

to 
node  belongs.  That 

fixed-topology  GHS  algorithm 
first 

topology  distributed  MST  algorithm 
initiated 

is  based  on  the  frag- 
to  the 
of  the  GHS 
by  a  node 
the 
is 
the  ingoing  and  outgoing  edges 
the  minimum  outgoing  edge 
topology 
into  several 
to 
to  this  con- 

ment  expansion  notion,  and  is  similar 
fixed 
protocol 
should 
fragment 
necessary  to  distinguish 
of  the  fragment,  and  find 
of 
environments, 
fragments.  Several  difficulties 
modify 
text.  The 
When  a  tree  link  e=(u,v) 
two 
fragments  are  formed  both  of  which  must  have  separate 
is  to  assign  the  identities 
identities.  A  natural 
(w(e),u)  and  ( w  e  v 
fragments  which  contain 
(  1,  1 
node  u  and  node  v,  respectively.  As  link  weights  and 
this  will 
node  identities 
suffice.  However, 
to 
two 
the  same  fragment 
nodes  in  separate 
these 
identity, 
at  the 
time  when 
nodes  is  tested 
and  thus,  a 
(to  see  if 
it 
to 
correct  MST  may  not  result. 
it 
situation 
see  that 
the 
assignment  of  fragment 
is  baaed  on  only  a  part 
(i.e.,  node  identities  and  link  weights  of 
of  the  fragment 
any  proper  subset  of  the  fragment). 

the  edge  connecting 
is  outgoing), 
In  fact, 

this  assignment  may 
fragments  having 

the  same  undesirable 
identity 

is  not  hard 
results 
if 

thought 
to 
the 

are  distinct, 

a  fragment, 

fails  within 

one  might 

fragment 

identity. 

think 

lead 

the 

There 

are 

two  ways 

to  avoid 
distinct 
first  approach 

situation 

the 
identities 
is  to 
let 

fragment.  With 

for 
described  above,  and  maintain 
the 
fragments.  The 
different 
identity  be  the  set  of  node  identities  of  all  the 
fragment 
that 
two 
nodes 
in 
identi- 
nodes  in  different 
ties  when 
them.  This 
testing 
approach  has  been  used  in  a  similar  problem  by  Segall 
the  message  size 
in  (131.  However,  with 
and  the  overall  bit  complexity  will 
increase,  as  a  sub- 
stantial  number  of  messages in  the  resilient  MST  proto- 
col  will  contain 

fragments  will  have  different 

the  edge  connecting 

this  assignment, 

this  approach 

the  fragment 

identity. 

e=(u,v) 

indicates  how  the  new  MST  can  be  obtained. 
Proposition 
pose 
link 
G(V,EU{e}) 
the 
that 
belong  to  V,  then  T’=T+e. 

3.1:  Let  T  be  the  MST  of  G(V,E).  Sup- 
of 
where  e’  is 
the  edges 
If  one,of  u  and  v  does  not 

is 
then  T’=T+e-e’ 

the  maximum  weight  among 

link  with 
form 

the  cycle  in  T+e. 

and  u,v~V, 

the  MST 

recovers. 

If  T’ 

recoveries, 

(as  in  Fig, 

In  order  to  extend 

l), 
3.1  must  be  first  applied 

if  the  cycles  formed  by  T+e 
If  the  cycles  overlap 

position  3.1  to  handle  many  simultaneous 
is  necessary  to  sequentially  apply 
Proposition. 
To  see this,  consider 
e 1  and  es.  The  rule  can  be  applied 
only 
joint. 
in  Proposition 
recoveries  and  then  the  remaining 
ceased on  the  resulting  graph.  The  order  in  which 
recoveries  are  processed 
Moreover, 
within 
it  forms  a  cycle  with  some  of  the  tree  links 
ment.  The  new 
above  rule 
MST). 

the  approach  suggested  by  Pro- 
it 
the  rule  given  by  this 
the  recovery  of  links 
to  both  recoveries 
I  and  T+e  z  are  dis- 
then 
the  rule 
to  one  of  the 
recovery  may  be  pro- 
these 
(see  131). 
recoveries 
recovers  within  a  fragment, 
in  the  frag- 
the 
final 

to 
(a  subtree  of  the 

important 
to 

is  also  a  fragment 

is  also  applicable 

derived  according 

fragments. 

fragment 

If  a  link 

is  not 

rule 

this 

w 

el 

Fig.  1 

e2 

The  properties  described  above  provide  a  basis  for 
features  of  which 

the  main 

the  resilient  MST  protocol, 
are  explained 

in  the  next  section. 

3.2.  Main 
mentation. 

Features 

of  The  Distributed 

Imple- 

In  a  changing  network  environment, 
and  recoveries  can  occur  simultaneously, 
can  occur  when  another  event 
any  moment, 
have  to  be  eventually 

link 
failures 
or  one  event 
is  being  processed.  At 
that  will 
combined.  Recoveries  can  happen 

there  can  be  several 

fragments 

332 

after 

) 
its 

approach 

immediately 

fails.  Then, 

An  alternative 

failure,  assign 

to  the  fragment 

to  the 
(w(e),v,k(e)) 

the 
node  u,  and 

identity.  Specially,  suppose 

is  to  have  a  counter 
times 

for 
the 
this  counter 
link 
if  k( e  is  the  counter  value  of  this 
identity 

each  link,  which  keeps  track  of  how  many 
link  has  failed  and  recovered,  and  attach 
value 
e=(u,v) 
link 
fragment 
(w(e),u,k(e)) 
the 
to 
identity 
node  v.  This  would  ensure 
identity 
fails.  Unfortunately, 
without 
the 
topological 
still  be  viable 
that  are  good  enough 
Notice 
fragment 
approach 

containing 
the 
containing 
that  a  new  and  distinct 
time  a  link 
cannot  be  bounded 
some  assumptions  on  the  time  or  the  order  of 
this  approach  may 
large  counters 
intervals. 
the 
first 

for  reasonably 
for 
the  messages  containing 
the 

identity  will  be  IV1  times 
than  with 

for  a  fragment  every 
the  counter 

changes.  However 

long  operating 

is  generated 

the  size  of 

the  second. 

in  practice 

fragment 

larger 

that 

in 

The  resilient  MST  protocol  described 

in  the  next 
section  could  be  used  with  either  one  of  the  approaches 
described  above  for  assigning  fragment 

identities. 

3.2.2. 

Response 

to  Link  Recovery. 

to 

the 

from 

have 

the  way 

recovers, 

identities. 

trees)  all 

When  a 

(note  that 

link  e=(u,v) 

the  appropriate 

is  denoted  as  the 

two  of  its  descendant 

receives  messages  corresponding 

in  the  cycle,  takes  action 
the  MST. 

then  both  end 
fragment 
If 
nodes  u  and  v  exchange 
their 
then  each  node  initiates 
both  are  in  the  same  fragment, 
a  process  to  find  the  maximum  weight  edge  in  the  cycle 
fragments 
by  propagating  a  message  upward 
to  the  root  of  the 
will  be  directed 
fragment.  The  messages  from  u  and  v  will 
‘meet’  at  a 
least  common  ancestor 
node,  which 
lca(u,v)  will  be  the 
(lea)  of  u  and  v.  In  other  words, 
node  which 
the 
(or  child) 
same  recovery, 
nodes.  This  node,  which  will 
information 
to 
about  the  maximum  weight 
If 
delete  and  insert 
fail) 
the  cycle  is  intact 
the  recovery  process,  the  goal  of  this  pro- 
throughout 
that  when  several 
ces  will  be  accomplished.  Observe 
the  same  fragment 
recoveries  occur  simultaneously 
in 
then  each 
and 
of  the 
recovery  process  can  be  performed 
their  processing 
if  the  cycles  overlap, 
others.  However, 
in  the  following  manner.  When  a  node 
is  sequentialized 
it  does  not  for- 
is  involved 
ward  messages  received 
its  descendants)  about 
other  recoveries.  Such  a  node  stores  the  messages  until 
the 
time 
one  of  the  stopped  messages will  be  forwarded  upwards. 
journey 
recovery 
deadlock  situation  may  occur. 

their 
the  root,  could  get  stopped  by  other 

towards 
processes,  a  potential 

recovery  process  is  completed  at  which 

As  messages  of  one  recovery,  on 

in  processing  one  recovery, 

in  the  cycle  do  not 

cycles  are  disjoint, 

the  corresponding 

independently 

(i.e.,  links 

(from 

links 

first 

into 

recovery, 

lea(e)  and 

forward  at 

to  Fig  2,  both 

in  recovery  processing  will 

(Referring 
lca(e’)  will  not 
receive  messages on  one  side  of  the  cycle).  As  each  node 
involved 
least 
one  recovery  message,  the  root  of  the  fragment  will  be 
informed  of  at  least  one  recovery.  The  root  will  select 
for  processing,  by  sending  a, 
the  first  arriving 
the  same 
privilege  message  which 
path  on  which 
the 
to  release  the  stopped  messages.  (In  Fig.  2,  the 
cycle 
travel 
privilege  will 
to  v 
the  stopped  message  at  x).  After 
and  upwards 
releasing 
is  informed  of  the  com- 
the  cycle  is  updated, 
the  root 
the  recovery  pro- 
pletion. 
cessing  also  avoiding  any  deadlock.  More 
implementa- 
tion  details  are  given  in  section  4. 

recovery  message arrived  and  around 

the  root  sequentializes 

travels  down  over 

to  u,  and  then 

the  root 

Thus, 

from 

Fig.  2 

3.2.3. 
cess. 

Interaction 

of  Failure 

and  Recovery 

Pro- 

F  can  be 

A 

fragment 

outgoing  edge  and  concurrently 

minimum 
or  more  link 
As  long  as  no  tree  link 
complete  and  update  the  fragment  correctly. 

finding 
its 
process  one 
it,  as  described  earlier. 
in  F  fails,  all  the  processes  will 

recoveries  within 

involved 

in 

A  note  of  caution 

is  in  order.  A  node  should  not 
for  its 
consider  any  of  its  recovered  links  as  a  candidate 
is  engaged  in  testing 
minimum  outgoing  edge  when 
in  the  MST  being 
its  outgoing  edges,  as this  may  result 
in  Fig.  3,  links  e r  and  es  may 
incorrect. 
be  included 
if  recovered 
links  are  not  con- 
sidered,  whereas  e e should  be  included 

(For  example 
in  the  MST 

instead  of  es.) 

it 

When 

in  F  fail, 

tree  links 

then  each  new  fragment 
generated  can  again  process  the  failures  and  recoveries 
in  F  causes  the  nodes  u 
within 
and  v  of  a  link 
to  be  in  two  different 
then  the  recovery  process  of  e will  stop  until 
fragments, 

recovery  e=(u,v) 

it.  If  a  tree  link 

failure 

333 

a  REIDEN-ACK<id> 

with 

responds 

node 
which  will  be  sent  upwards 
ment 
root 

root.  When 
then  all  nodes  know 
To 

the  minimum 

to  the 

find 

from 

the 
this  message 
the  current 

outgoing 

message 
frag- 
the 

by 

leaves  of  the 
is  received 
fragment 
edge, 

identity. 
the 

root 

fifind  state  and  performs 
in  which 

the 

root  broadcasts 

another 

broadcast- 
a  FINDMOE 

fragment. 
into 

A  node 
find 

and 
message  over  each  of  its  non-tree 

state 

the 

receiving 

receives  such  a  message  may 
a  REJECT<id>, 

or  with 

this  mes- 
sends 
a 
links.  A 
respond  with  an 
which 
indi- 
is  outgoing. 

or  not 
id  sent  with 

response, 

the  non-tree 

link 

as  the 

the  TEST  message  must  be 
the 
is  the  same 

id  may  change 
The 

reason 

in 

failures. 

id  to  the  echo  in  every  broadcast-echo 
its  parent 

the  echo,  node  u  sends 

to 

>  message 

,  where  w, 

the  outgoing 

edge 

found 

by 

a  node  sends 

this  message 
root 
receives 

state.  When 

message 

from  all 

the 
its  children 

the  minimum 

outgoing 

edge 

this 

over 

root 

point 

the 
the  path 

that 
changes  occur, 
similar 

in  a  manner 

topological 

the  end  node  of  the  moe  receives 

a 
is  the 
the 
it 
a 

sends 

it  knows 
(or  moe)  of 
a 
to  the 

leads 
the 
resilient 
to  the  GHS 
the 
message 

fragments 

fragment 

to 

fragments, 

time  due  to  other 

in 

the 

the 

that 

also 

the 
the 

the 
enters 

enters 
with-echo, 
message  over 
sage 
TffST<id> 
node 
that 
ACCEPT<id> 
cates  whether 
(Note 
returned 
mean 
for  attaching 
phase).  During 
FINDMOE-ACK<id,w, 
minimum 
weight 
descendants 
enters 
the 
FINDMOE-ACK 
the  weight 
the 
CHANGE-ROOT<id> 
moe. 
then  proceeds 
protocol 
protocol, 
ie.,  when 
CHANGE-ROOT<id> 
to  over 
and  starts 
find  a  new  moe.  Note 
each 
choose 

of 
fragment. 

the  outgoing 

If  no  other 

finding 

At 

of 

of  u.  After 
found 

edge 
a  process  over 

it  sends  a  CONNECT 
two 

to  merge 
the 
if 

the 
“extended” 
there  are  m 

that 

then  at  least 
edge. 

its  own  moe, 

two  of  them  will 

the  same  outgoing 
that  other 
is  being  performed. 

topologicaI 

fails  and  u’ 

Such  a  failure 

divides 

As  explained 
fragments. 

message 
identity 
the  root 

failure 

process 

fragment. 

fragments. 

link  e’=(u’,v’) 

id’ 
is  the  new 
failure.  When 

Suppose 
this  process 
that 
the 
two  more 
the  root  of  one  of  the 
a  FAILURE<id’> 
where 
recent 
will 
last 
and 
failure 
doned 
failure 
messages 
fragment. 

a  new 
by  giving 

start 
failure 
finding 

contain 

that 

a  new 
a  new  outgoing 

process 
because 
has  now  been  divided. 

initiated 
by 
the  original 

the 

For 
instance, 
is  the  parent 

changes  occur  while 
assume 
in 
of  v’ 
into 
before  v’  will  become 
u’  will  send 
However, 

fragment 

the 

root  of  its  fragment, 

to  the 
corresponding 
receives  such  a  message 

to  the  most 
it 
the 

to 

to 

corresponding 
its  current 
edge.  Observe 
the 
failure  of  e  will  be  aban- 
that 
any 

fragment 
that 

A  node  will 

by 
ignore 

created 

fragment 

id 

the 

identity 

given 

to  the  original 

Fig. 

3 

fragments  merge  and  nodes  u  and  v  belong 

Conversely, 
recovered 
for 

fragment 

if 
links 

to 

the 
the  outgoing 
links  of  a 
then  only  one  of  them 
in 

as  described 

expansion, 

fragment. 

the 
same 
fragment 
will  be  selected 
detail 

are  all 

in  the  next  section. 

MST 

Protocol. 

4.  Description 

of 

the  Resilient 
In  this  section,  we  describe 
involved 
(A 

in  updating 

formal 

description 
initial  MST 

and 

the  MST, 

the  actions 

is  given 
is  a  directed 

taken  by  a 
the  messages 
It 
is 
tree. 
in  sleep  state.  First,  we  shall 
and 
and 

failure 
failures 

[3]). 
rooted 

courses  of 

in 

interaction 
is  described 

when 
later. 

the 

that 
all  nodes  are 
separately 
processes.  The 
in  time 
overlap 

the  normal 

node 
used. 
assumed 
Initially, 
describe 
recovery 
recoveries 

failure 

of  any 
recovered 

its  adja- 
it 
links, 

where 

node  u  is 
fails,  node  u  (in  sleep 

generated 

to  its  parent, 
by 
failure 

the 

4.1. 

Failure 
When 

Response. 

a  node  detects 

the 

cent  non-tree 
deletes 
simply 
Consider 

links 
it  from 
any 

or  unprocessed 

its  local  memory. 

tree 

link  e=(u,v), 

link 

id(e) 

If  this 

identity 

is  the  new 

the  parent  of  node  v. 
state)  sends  a  message  FAILURE<id(e)> 
where 
of  e  (as  explained 
propagated 
ing 
its 
marks 
and  also  enters 

this  message  enters 
identity 

to  be 
itself  as  the 
the 
Upon  entering 

id(e).  Node 
root 
(of  the 
reiden  state. 
the 

upwards 

reiden 
in  which 

phase 

broadcast-echo 
sage  REIDEN<id> 
nodes 
message, 
identity 

to  the 

in  the 

changes 

which 

travels 

fragment. 

Every 

node 
reiden 

to  the  root. 

in  section  3.2.1).  This  message  will  be 
receiv- 
into  a  reiden  state,  and  changes 
hand, 
v), 

v,  on 
fragment 

root  upon 

the  other 

containing 

The 

the 

root  enters  a 
state, 
the  mes- 
it  broadcasts 
the 
to  all 
receives  such  a 

down 
that 

tree 

its  state 

to 

and 

its 

fragment 

identity 

contained 

in  the  message.  Each 

334 

If  the  root  of  a  fragment 
going  edge  (i.e.,  either 
the 
network  or  it  is  disconnected 
work), 
the  and  enters  into 
such  a message will  also  into  the  sleep  state. 

finds  that 
there  is  no  out- 
fragment  spans  the  entire 
the  rest  of  the  net- 
it  broadcasts  a  GOSLEEP  message  over 
the  sleep  state.  A  node  that  receives 

from 

then 

of 

in  [3]). 

failures, 

4.1:  Corresponding 
there  is  no  recovery), 

the  protocol 
the  following  proposi- 

the  above  description 
for  link 

Based  on 
implementation 
tion  is  presented  (the  proof  can  be  found 
to  a  set  of  failures 
Prooosition 
(suppose  that 
if  the  final  graph 
is 
still  a  connected  graph,  then  the  tree  maintained  by  the 
protocol 
is  the  MST  of  the  final  graph  and  each  node 
returns 
if  the  final  graph 
to  the  sleep  state;  otherwise, 
in  each  connected  com- 
becomes  disconnected, 
ponent, 
the  MST  of  this  sub- 
graph  and  each  node  in  each  connected  component  will 
enter  the  sleep  state. 

the  protocol  maintains 

then, 

4.2.  Recovery 

Response. 

to 

to 

sends 

is  the 

Initially 

recover 

parents, 

and 
its 

that  detect 

the  message  is  simply 

link  e=(u,v). 
(with 

the 
messages  where 

at  each  node,  change  their  states 

Consider  a  recovered 
all 
nodes  are  in  a  normalstate 
respect  to  recoveries). 
The  end  nodes 
recovery,  exchange 
fragment 
id 
ID-CHECK<id> 
identity 
to  recover, 
and  send  a  RECOVERY<id,w(e),w(p)>, 
where  w(p)  is 
the  weight  of  the  link  going  to  the  parent.  A  node  that 
checks  if  the  frag- 
receives  a  RECOVERY<id,w(e),w> 
id  is  not  the  same 
ment  id  is  the  same.  If  the  fragment 
then  a  failure  has  happened  and  the  fragment 
is  being 
reidentified.  Thus 
ignored.  Con- 
versely, 
if  the  id  is  the  same  then  the  node  changes  its 
state 
wherz 
RECOVERY<id,w(e),w’> 
where  w(p)  is  again  the  weight  of  the 
w’=max{w,w(p)} 
to  the  parent  of  the  node.  This  process  is 
link  going 
least  com- 
continued  until 
lca(u,v).  This 
mon  ancestor 
message  from  u  and 
node  will 
first. 
from  v.  Suppose  that 
Then 
the  RECOVERY 
the 
parent  of  the  lea  node  as  explained  above.  Conversely, 
the  message  from  u  will  not  be  forwarded. 
it 
will  be  stopped  at  the  lea  or  further  action.  When 
the 
root  receives  the  RECOVERY<id,w,w’> 
message from 
a  child 
mes- 
sage  which 
the  serial- 
ization  of  the  recoveries  (see Section  3.2.2).  If  this  mes- 
sage  reaches  the  lca(u,v)  after  the  second  RECOVERY 
from  v  then 
because  no  serialization 
second  RECOVERY 
then 

to  the  root 
if  the 
message  has  not  been  received 
the 

it  responds  with  a  PRIVILEGE<id,w,O> 
functions  as a  token  that  permits 

the  message  arrives  at  the 

message  is  forwarded  over 

the  message  from  v  arrives 

of  u  and  v,  denoted  by 

is  necessary.  Conversely, 

message  is  forwarded 

receive  a  RECOVERY 

this  PRIVILEGE 

the  PRIVILEGE 

is  returned 

Instead 

to 

If 

lca(u,v) 

over  the  appropriate  path. 
the 

the  node  will 

reaches  a  node 

that  has 
message  (i.e.  because  another 
release  the 
lca(u,v). 
the 
to  the  root. 
the  root  will  send  a  new 

reach 
will 
is  returned 

this  point 

is  another 

the  PRIVILEGE 

the  RECOVERY 
is  taking  place)  then 

cycle. 
stopped 
recovery 
message  and  the  RECOVERY 
the  PRIVILEGE 
At 
If  there 
recovery, 
PRIVILEGE 
finally 
When 
messages  it  starts 
RECOVERY 
replace  the  edge  in  the  cycle  with 
To  do  this, 
cycle. 
the  link  with 
link  as a  non-tree 
forwards 
hand,  a  node  that 
maximum  weight  will  change 
forward 
the  original  REPLACE 
receives  a  REPLACE<id,w(e),oo> 
parent-child 

a  REPLACE<id,w(e),oo>. 
is  not  adjacent 

If  the  node  receiving 

the  message  is  adjacent 
it  marks 

two 
the  process  that  will 
the  maximum  weight. 
over  the 
to 
the 
link,  changes  its  state  to  normal,  and 
the  other 
the 
to  normal  and 
message.  A  node  that 
the 

to  the  link  with 

it  sends  a  REPLACE<id,w(e),w> 

the  maximum  weight 

its  state 

receives 

relation. 

reverse 

then 

the 

On 

will 

It  should  be  clear 

that 

in 

the 

implementation 

described  above,  the  recovery  processes  proceed  sequen- 
tially  as suggested  in  Section  3.2.2. 

of 

the 

link 

recoveries, 

is  presented  (the  proof  can  be found 

4.2:  Corresponding 
there  are  no  failures), 

the  above  description 
for 

the  protocol 
Based  on 
following 
the 
implementation 
in  [3]). 
proposition 
to  a  set  of  recoveries 
ProDosition 
if  the  final  graph  is 
(suppose  that 
then  the  tree  maintained  by  the 
still  a  connected  graph, 
is  the  MST  of  the  final  graph  and  each  node 
protocol 
to  sleep  state;  otherwise, 
returns 
final  graph 
in  each  connected  com- 
becomes  disconnected, 
ponent, 
this 
subgraph  and  each  node  in  each  connected  component 
also  enters  sleep  state. 

the  protocol  still  maintains 

the  MST  of 

then, 

the 

if 

of  Failures 

and  Recoveries. 

4.3. 

Interaction 
Suppose 

that  a  node  u  is  the  Cca of  an  ongoing 
assume  that  u  is  also 
in  a  failure  process.  Then  u  will  hold  the 
the  failure  process  is  finished. 
that  a  failure  process  may  cause 
this  only  hap- 

recovery  process.  Furthermore, 
participating 
REPLACE 
Note  that 
a  delay  in  the  recovery  process.  However, 
pens  in  some 

message  until 
this 

instances. 

implies 

Suppose  now  that  one  of  the  link 
recovery  process  fails.  Then 

ongoing 
fragment  will 
generated  by 
they  will  contain 
recovered 
they 
nodes  can  “remember” 

in  the  cycle  of  an 
the  nodes  in 
the 
and  the  messages 
recovery  will  be  discarded  because 
the  old  identity.  The  end  nodes  of  the 
link  will  start  a  new  recovery  process  (after 
the  end 
link 

identities).  Note 
the  recovery  because  the 

receive  a  new  identity 
the 

their  new 

receive 

that 

335 

defined  on  G&  , which 
of 

the  correctness 

includes 
the  protocol 

Now, 

(u,v).  0 

can  be  esta- 

link 

fragment 

(u,v)  was  a  recovered 

link  at 
and 
formed  by  adding 
than 
before 

time 
is  a  tree 
there 
into 
this 
(u,v) 
the  weight 
the 
there  are  only 

link  before 
t.  Then,  either 
link 
frag- 
of  (u,v>, 
of 
links 
node  u,  to  other 

installation 
recovered 

is  greater 

including 

first  case,  due 

there  are  simultaneous 
the  weight 
(u,v) 
induced 

is  with 

link 

of 

to  Proposition 
recovery 
less  than 
subgraph 
by  y,  assuming 

fragment 
of  y.  Thus,  based  on  Proposition 

the 
rooted 

the  MST  of  G&  which 

case, 
a  tree 
the  of 

(u,v)  will 
link  at 
the 

includes 
be 
time 
induced 

(u,v)  at 
the  only 
t.  Thus, 
subgraph 
node  u.  There- 
the  com- 

of 

to  the 
case, 

fragment 
(u,v) 

including 

is  in 

the  MST 

has  been  deleted 

link;  or 

the  component, 
of  G&. 
In  the 

that 

Suppose 
t  and  becomes  a  tree 
is  inside 
in  the  cycle 

some 

(x,y) 

time 
(u,v) 
(x,y), 
ment,  whose  weight 
and 
(u,v)  as  a  tree 
connecting 
components 
4.2  which 
and 
failure 
any  outgoing 
corresponding 
that 
3.1  (u,v) 
time 
t. 
recovered 
(u,v) 
is 
corresponding 
fore, 
ponent, 

in  either 

x 

is  the  parent 

holds  when 
processes, 

non-tree 
to 
the 

the 

is  in 
In 
second 
link  becoming 
the  moe  of 

Since 

of  the 

the  notification 

link  will  arrive  at  the 

the  connection 
where 

failure 
the  moe  which 

fragment 
disconnected. 
the  case  that 

blished. 
Theorem 
each  component 
Proof: 
any 
there  exists 
the 
finds 
process  and 
t,  or 
the 
becomes 
Also, 
in 
the  outgoing 
only  one  of  them, 
two 
finite 
time  after 
be  one  spanning 
graph. 
recovered 
implies 
tree 
no  deadlocks 
a  time 
to  be  the  maximum 
fact, 
> 
holds 
spanning 
is  an  MST  of  that  component 

recovered 
link 
(as  described 
t,  s.t.  G&  =  GL 

link  or  a  non-tree 

say 
including 

throughout 

ts.  This 

Therefore, 

link  will 

fragments 

each 

that 

5.1:  The  algorithm 

constructs 

an  MST 

for 

final  graph. 

of  topological 

two  end  nodes 

in  finite 

change  on 
time, 
t  r.  Besides, 
t  only 
it 
failure 
time 

if 

done  at 

t  r  s.t.  GL  =  G,! 
process  will 

terminate 

for  all 
at 

t  > 
time 

is  not  selected  by  any  other 

is  successfully 

this 

failure 
with 
ail  other 
there  are  only 

edges  of  some 

fragment, 

process  originated 
fragments 
recovered 
then 
to  merge 

(u,v),  will  be  used 

u  and  v  respectively. 
topological 
change 

last 

the 
tree  on  every 
that 
inside 

from 
be 

component 

time 
some 

of 
onward, 
fragment. 

link  will  either 

time  since 

in  finite 
in  Section  4.  Hence, 
for 
of  t  r  and 

time 
t 2.  If  we 
t2,  then  GE  =  Gb 

t  > 

combined 
the  computation, 

with  Property 

will 

imply 

the 

Thus, 

in  G&. 
links  as 
one  and 
the 
in 
there  will 
final 
every 
This 
become 
a 
there  are 
is 
t, 
t 

there 
let 

for 
5.1  which 
the 
t, 

t  > 

that 

tree  T  on  each  component 
of  the 

for 

of  G& 
final  graph.  q 

remains 

unclassified. 

We  have 

described 

how  a 

recovery 
affect  a  failure 

process. 

However, 

a  link 

process  as  follows. 

failure  may 

a 
recovery  may  also 

affect 

hold  any  message 
topology 

the 

These  messages  will 

its 

for 

return.  At 

Ica  node  has  sent  a  REPLACE 
the 
time 
over 
the 
is  being 
the 
that 
it 

this 
travel 
cycle 
sent  when 
a  node 

that  will 
the 
be 

Similarly, 

of 

is  returned. 

lea  will  hold  any  FAILURE  message  when 

in  a  recovery 
is  being  changed 

process  because 

the 

topology 

and 

the  parent-child 

rela- 

because 

that 
an 
is  waiting 

Assume 
message  and 
node  will 
cycle 
adjusted. 
REPLACE  message 
is  not  an 
is  involved 
of  the  cycle 
tions  are  being  changed. 
It  can  be  observed 
failures 
l 

still  hold  when 
ously 
(see  [3]). 

that  Propositions 

4.1  and  4.2 

and 

recoveries 

occur  simultane- 

5.  Proof  of  Correctness. 

we  briefly 

outline 

the  correctness 

In 

the 

(x,y) 

at  all 

following, 
proof  of  the  protocol. 
Let  Gj  denote 
the 

to  be  the 

and  E(G&) 

times). 
network, 
network  without 

the  nodes  and 
Define  Gi 
information 
the 
words,  a  link 
have 
recorded 
the  delays 
identical 
computational 
logical 
=  V(Gi) 
in  R  t 
it  as  a  recovered 
ProDertv 
if  a  link 
(u,v) 
is 
includes 
Proof: 
before 
due 
mixture 
described 
specific 
on 
the 
MST  of  the  component, 
(u,v). 

(u,v) 
in 
(u,v). 
Suppose 

to  Proposition 
failure 

edge. 
5.1:  At  any 

the  MST 

time 

that 

of 

stored  at  each  node  at  time 

is  in  CL 

links 

that  are  operational 

the  physical 

logical 

time 

network 

network 

corresponding 

at  time 
at 

t  i.e., 
t. 
to 
t.  In  other 
if  both  node  x  and  node  y 
to 
Gj  and  GL  may  not  be 
to  define  a 
the 

as  GE,  which 

(Note 

that, 

due 

is 

links 

i.e.,  V(G&) 
-  R  t,  where  an  edge 

is 

It 

is  also  convenient 
denoted 
the 

recovered 

=  E(Gi) 

(x,y)  as  operational. 

in  the  notifications, 

if  either  or  both  of  its  end  nodes  have 

recorded 

time 

t  during 

the  computation, 

is  classified 
of 

as  a  tree 
the  component 

link  by  node  u,  then 
of  GE  which 

t  and  becomes  a  tree 

link 
t.  Then, 
there 

link 

(u,v)  was  a  non-tree 

link  at 

recovery 

time 
4.1  which  holds  even  when 
processes  and 

is 
processes  as 
(u,v)  must  be  an  moe  of  some 
based 
the 
in 
includes 

Therefore, 
is 

defined  on  G&,  which 

(u,v) 

in  section  4.3, 

set  of  nodes  defined  on  G&. 
fragment 
property, 

expansion 

1  Also 
between 

see 

(3) 

for  a 

further 

discussion 

on 

the 

interactions 

failure  and  recovery  processes. 

336 

6.  Complexity 

Analysis. 

References 

that 

the  FAILURE 

Suppose  that 

the  new  identity 

message  travels  over 

the  network  has  n  nodes  and  e edges. 
Moreover,  assume  that  a single  failure  occurs.  It  can  be 
noted 
the 
broad- 
edges  of  a  tree  with  O(n)  messages.  Similarly, 
casting 
the 
require  O(n)  mes- 
new  moe,  and  merging 
sages  since  these  activities 
the  edges  of 
are  done  over 
the  tree.  However, 
the  minimum  outgoing  edge 
to  find 
fragments,  messages  need  to  be  sent  over  O(e) 
of  the 
non-tree 
for  a  sin- 
gle  failure 

the  message  complexity 

is  O(e)  messages. 

the  fragments 

links.  Thus 

fragment, 

of  the 

finding 

Suppose  now  that  a  single  recovery  occurs.  As  in 
links  of 
links  are  traversed.  Therefore, 
is  O(n)  messages. 

the  above  case,  the  messages  travel  only  over 
the  tree  and  no  non-tree 
the  complexity 

for  a single  recovery 

failures 

As  mentioned 

in  previous  Sections,  some  of 

to  find  its  moe  is  lost.  Therefore, 

the 
of  a  failure  or  a  recovery  may  be  lost  because 
activity 
(see  Sections  4.1  and  4.3). 
of  subsequent 
Nevertheless,  when  a  link 
failure  occurs  within  a  frag- 
ment  F,  it  suspends  any  failure  process  in  progress  in  F 
as  well  as  the  concurrent 
recovery  processes  in  F  (if 
any)  and  a  completely  new  process  is  started.  Note  that 
failure  processes,  the  effort 
for  each  of  the  suspended 
the  messages 
devoted 
lost  are  bounded  by  2ef6n.  Similarly, 
suppose  that  all 
suspended 
in  dis- 
joint  cycles  of  the  fragment.  Then 
the  messages in  each 
traverse  on  the  links  of  the  relevant  cycle. 
process  only 
Thus, 
the  total  number  of  wasted  messages  is  at  most 
the  protocol  uses  only  O(me+kn)  mes- 
3n.  Therefore, 
for  the  final  graph  where 
sages  to  reconstruct  an  MST 
m  and  k  are 
failures  and 
recoveries  respectively.  Note 
that  e  and  n  refer  to  the 
maximum  number  of  edges  and  nodes  in  the  graph  dur- 
ing  the  computation. 

recovery  processes  are  taking  place 

the  numbers  of 

tree 

link 

the  cycles 

The  best  case  message  complexity 

O(n)  when 
disjoint.  The  best  case  message  complexity 
is  O(e)  when  all 
different 

is 
these  recoveries  are 
for  failures 
the  fragments  except  one  choose  the 

for  recoveries 

formed  by 

links  as their  respective  moe. 
case  time  complexity 

that 

(evaluated 

The  worst 

it  takes  one  time  unit 

link) 
the  computation. 

assuming 
across  any 
used  during 
plexity 
height  among  the  fragments  created  during 
tation. 

to  O(H)  where  H 

by 
to  send  a  message 
to  number  of  messages 
The  best  case  time  com- 
the  maximum 
the  compu- 

is  also  equal 

is  equal 

is 

Weight 

Spanning 

Evanston, 

University, 

a  Minimum 

to  Maintain 

in  Multihop 

and  S.  Even, 

in  a  Dynamic 

and  S.  Kutten, 

Radio  Networks,” 

“A  Resilient  Distri- 

“An  Almost  Linear  Time 

“A  Protocol 
Tree 

“Optimal  Distributed  Algorithm 

Topology,”  M.S. 
IL, 

for 
Tree,  Counting, 
Symp. 

“Reliable  Broadcast 
in  Unreliable  Networks,”  Networks,  vol. 

Algorithm 
Spanning  Trees,”  26th  Symp. 
of  Comp.  Sci.,  pp.  257-266,  Port: 

“Tree-Based  Broad- 
IEEE 
on  Comp.,  vol.  C-36,  no.  10,  pp.  1209-1223, 

B.  Awerbuch 
Protocols 
16,  no.  4,  pp.  381-396,  Dec.  1986. 
B.  Awerbuch, 
Minimum 
Leader  Election, 
and  Related  Problems,” 
Theory  of  Comp.,  pp.  230-240,  May  1987. 
C.  Cheng, 
Spanning 
Thesis,  Northwestern 
June  1988. 
F.  Chin  and  H.F.  Ting, 
and  O(nlogn+e)  Messages  Distributed 
for  Minimum-Weight 
on  Foundations 
land,  OR,  Oct.  1985. 
I.  Chlamtac 
casting 
Trans. 
Oct.  1987. 
LA.  Cimet  and  S.P.R.  Kumar, 
for  Network 
buted  Protocol 
ACM  SIGCOMM 
and  Pro- 
Symp.  Commun.  Arch. 
tocols,  pp.  358-367,  Stowe,  VT,  Aug.  1986.  Also  in 
Computer  Communications  Review, 
vol.  16,  no.  3. 
“A  ResiIient  Distri- 
LA.  Cimet  and  S.P.R.  Kumar, 
buted  Algorithm 
Spanning 
Proc.,  pp.  196-203, 
Trees,” 
St.  Charles, 
Y.K.  Dalal  and  R.M.  Metcalfe, 
“Reverse  Path  For- 
warding  of  Broadcast  Packets,”  Commun.  ACM, 
vol.  21,  no.  12,  pp.  1040-1048,  Dec.  1978. 
N.  Francez, 
Termination,” 
TOPLAS, 
E.  Gafni, 
of  Two  Message-Optimal  Election  Algorithms,” 
ACM 
175-185,  Minaki,  Ont,  Canada,  Aug.  1985. 
R.G.  Gallager,  P.A.  Humblet,  and  P.M.  Spira,  “A 
Distributed  Algorithm 
for  Minimum  Weight  Span- 
ning  Trees,”  ACM 
Lang.  Syst., 
vol.  5,  pp.  66-77,  Jan.  1983. 
R.  Perlman, 
111-111,  asfasfsaf,  date. 
A.  Segall,  “Distributed 
Trans. 
Jan.  1983. 

vol.  2,  no.  1,  pp.  42-55,  1980. 
“Improvements 

IEEE 
IT-29,  no.  1,  pp.  23-35, 

4th 
of  Dist.  Comp.,  pp. 

in  the  Time  Complexity 

Int’l  Con/.  on  Parallel 

Network  Protocols,” 

for  Minimum-Weight 

Synchronization,” 

IL,  Aug.  1987. 

Trans.  Program. 

on  Principles 

“Distributed 

Inf.  Theory, 

‘&Gateway 

routing,” 

safasasf, 

Symp. 

ACM 

pp. 

vol. 

1. 

2. 

3. 

4. 

5. 

6. 

7. 

8. 

9. 

10. 

11. 

12. 

13. 

337 

APPENDIX: 
Algorithm 

Formal 

Description 

of 

the 

Resilient 

This  appendix  presents  a  brief  formal  description  of  the 
is 
the  messages  and 
that  some 

:haL  the  reader 
used  in  the  GHS  algorithm.  Also  note 

(for  a  complete  description 

is  familiar  with 

resilient  protocol 
assumed 
variables 
trivial  parts  are  omitted. 

see  [31). 

It 

for  link  (u,v). 

end  when 

if  f-state=reiden 

or  f-state=jindmoe 

send  FAZLURE<fid> 
if 

to  parent. 

then 

if 

end 
if 

end 

over  (u,v). 

else 

(1)  Response  of  node  u  to  failure  notification 
if  (u,v) 

is  a  tree  link 

then 
generate  new  fragment 
if  u  is  a  child  of  v  then 

identity 

lid. 

u  becomes  the  root  of  fragment. 
f-state+reiden. 
idtfid. 
send  REIDEN<id> 

to  all  children. 

if  f-state=jound 

then 

hold  FAILURE  message. 

else 

else 

end 
if 

end 
if 

end 

(2)  Response  of  u  to  FAZLCJRE<fid> 
if  u  is  root 
idtfid; 
send  REZDEN<id> 

then 

to  all  children. 

else 

end 

send  FAZLURE<fid> 
if 

to  parent. 

(3)  Response  of  u  to  REZDEN<fid> 
idcfid. 
f-state+-reiden. 
if  u  has  no  children 

then 

send  REZDEN-ACI(<id> 

to  parent. 

else 

end 

send  REZDEN<id> 
if 

to  all  children. 

(5)  Response  of  u  to  FZNDMOE<fid> 
if  id=fid 

then 

over  (u,v). 

use  TEST<id> 
if  u  has  no  children 

then 

to  find  all  incident  outgoing  edges. 

send  FZNDMOE-ACK<id,moe> 
(moe  is  the  local  moe  of  u) 

to  parent. 

send  FZNDMOE<id> 
if 

to  all  children. 

(6)  Response  of  u  to  FZNDMOE-ACK<fid,e> 
if  id=fid 

then 

over  (u,v). 

if  u  is  leader  then 

send  CHANGE-ROOT 

to  child  who  reported  moe. 

else 

end 

else 

if  u  received  FZNDMOE-ACK 

from 

every  child 

then 

send  FZNDMOE-ACK<id,moe> 

with 

local  moe. 

to  parent 

over  (u,v). 

(7)  Response  of  u  to  CHANGE-ROOT<fid,e> 
let  a  child  of  u  be  the  parent. 
if  e is  an  incident 

link 

send  CONNECT 

then 
over  moe. 

send  CHANGE-ROOT 

in  FINDMOE-A 

CK. 

to  child 

that 

reported  e 

end 

if 

(8)  Response  of  u  to  recovery  notification 
if  u  and  v  are  in  the  same  fragment 

then 

for  (u,v). 

(9)  Response  of  u  to  RECOVERY<fid,w,w’> 
if  u  received  a  RECOVERY  message  from  node  x 

over  (u,v). 

for  the  same  recovery 

then 

wait 

until  u  has  received  echo  then 

send  REPLACE 

to  child  reporting  maximum  weight 

over  (u,v). 

end 

send  RECOVERY 
if 

to  parent. 

(4)  Response  of  u  to  REZDEN-ACK<fid> 
if 

id=fid 

then 

if  u  received  REZDEN-AQZ<<fid> 

over  (u,v). 

from  every  child 

the1 

end 

end  wait 
if 

if  u  is  leader  then 

send  FZNDMOE<id> 
f-state+-find. 

to  all  children. 

else 

end 
if 

end 
if 

end 

send  REZDEN-ACZ(< 
if 

id > 

to  parent. 

338 

